# å®éªŒå››ï¼šç”¨æˆ·ç¨‹åºä¸ç³»ç»Ÿè°ƒç”¨

!!! danger "åœ¨æ‰§è¡Œæ¯ä¸€æ¡å‘½ä»¤å‰ï¼Œè¯·ä½ å¯¹å°†è¦è¿›è¡Œçš„æ“ä½œè¿›è¡Œæ€è€ƒ"

    **ä¸ºäº†ä½ çš„æ•°æ®å®‰å…¨å’Œä¸å¿…è¦çš„éº»çƒ¦ï¼Œè¯·è°¨æ…ä½¿ç”¨ `sudo`ï¼Œå¹¶ç¡®ä¿ä½ äº†è§£æ¯ä¸€æ¡æŒ‡ä»¤çš„å«ä¹‰ã€‚**

    **1. å®éªŒæ–‡æ¡£ç»™å‡ºçš„å‘½ä»¤ä¸éœ€è¦å…¨éƒ¨æ‰§è¡Œ**

    **2. ä¸æ˜¯æ‰€æœ‰çš„å‘½ä»¤éƒ½å¯ä»¥æ— æ¡ä»¶æ‰§è¡Œ**

    **3. ä¸è¦ç›´æ¥å¤åˆ¶ç²˜è´´å‘½ä»¤æ‰§è¡Œ**

## åˆå¹¶å®éªŒä»£ç 

!!! tip "å¦‚ä½•ä½¿ç”¨æœ¬æ¬¡å‚è€ƒä»£ç "

    æœ¬æ¬¡ç»™å‡ºçš„å‚è€ƒä»£ç ä¸º**å¢é‡è¡¥å……**ï¼Œå³åœ¨ä¸Šä¸€æ¬¡å®éªŒçš„åŸºç¡€ä¸Šè¿›è¡Œä¿®æ”¹å’Œè¡¥å……ã€‚å› æ­¤ï¼Œä½ éœ€è¦å°†æœ¬æ¬¡å‚è€ƒä»£ç ä¸ä¸Šä¸€æ¬¡å®éªŒçš„ä»£ç è¿›è¡Œåˆå¹¶ã€‚

    æ–‡ä»¶çš„ç›®å½•ä¸ä¸Šä¸€æ¬¡å®éªŒç›¸åŒï¼Œå› æ­¤ä½ å¯ä»¥ç›´æ¥å°†æœ¬æ¬¡å‚è€ƒä»£ç çš„ `src` ç›®å½•ä¸‹çš„æ–‡ä»¶å¤åˆ¶åˆ°ä¸Šä¸€æ¬¡å®éªŒçš„ç›®å½•ç»“æ„ä¸‹ï¼Œè¦†ç›–åŒåæ–‡ä»¶ã€‚

    åˆå¹¶åçš„ä»£ç å¹¶ä¸èƒ½ç›´æ¥è¿è¡Œï¼Œä½ éœ€è¦åŸºäºåˆå¹¶åçš„ä»£ç ã€æŒ‰ç…§æ–‡æ¡£è¿›è¡Œä¿®æ”¹è¡¥å……ï¼Œæ‰èƒ½é€æ­¥å®ç°æœ¬æ¬¡å®éªŒçš„åŠŸèƒ½ã€‚

!!! warning "é¡¹ç›®ç»„ç»‡è¯´æ˜"

    1. æœ¬æ¬¡å®éªŒä¸­ç»™å‡ºçš„å‡ä¸º**å‚è€ƒä»£ç ç‰‡æ®µ**ï¼Œæ‰€æœ‰**ä»£ç å†…å®¹ã€ä»£ç ç»“æ„**å‡å¯æŒ‰ç…§éœ€è¦è‡ªè¡Œè°ƒæ•´ã€‚
    2. éƒ¨åˆ†ä»£ç çš„ä½¿ç”¨**éœ€è¦è‡ªè¡Œè¡¥å…¨ `lib.rs` å’Œ `mod.rs` ç­‰æ–‡ä»¶**ï¼Œä½ ä¹Ÿå¯ä»¥**æ·»åŠ ã€ä¿®æ”¹ä»»ä½•æ‰€éœ€å‡½æ•°**ã€‚
    3. åŠŸèƒ½åœ¨é€æ­¥å®ç°çš„è¿‡ç¨‹ä¸­ï¼Œéƒ¨åˆ†æœªä½¿ç”¨ä»£ç å¯ä»¥è¿›è¡Œæ³¨é‡Šä»¥é€šè¿‡ç¼–è¯‘æ£€æŸ¥ã€‚

åœ¨ `pkg/app` ä¸­ï¼Œå®šä¹‰æä¾›äº†ä¸€äº›ç”¨æˆ·ç¨‹åºï¼Œè¿™äº›ç¨‹åºå°†ä¼šåœ¨ç¼–è¯‘åæä¾›ç»™å†…æ ¸åŠ è½½è¿è¡Œã€‚

åœ¨ `pkg/syscall` ä¸­ï¼Œæä¾›ç³»ç»Ÿè°ƒç”¨å·å’Œè°ƒç”¨çº¦æŸçš„å®šä¹‰ï¼Œå°†ä¼šåœ¨å†…æ ¸å’Œç”¨æˆ·åº“ä¸­ä½¿ç”¨ï¼Œåœ¨ä¸‹æ–‡ä¸­ä¼šè¯¦ç»†ä»‹ç»ã€‚

åœ¨ `pkg/lib` ä¸­ï¼Œå®šä¹‰äº†ç”¨æˆ·æ€åº“å¹¶æä¾›äº†ä¸€äº›åŸºç¡€å®ç°ï¼Œç›¸å…³å†…å®¹åœ¨ä¸‹æ–‡ä¸­ä¼šè¯¦ç»†ä»‹ç»ã€‚

åœ¨ `pkg/kernel` ä¸­ï¼Œæ·»åŠ äº†å¦‚ä¸‹ä¸€äº›æ¨¡å—ï¼š

- `interrupt/syscall`ï¼šå®šä¹‰ç³»ç»Ÿè°ƒç”¨åŠå…¶æœåŠ¡çš„å®ç°ã€‚
- `memory/user`ï¼šç”¨æˆ·å †å†…å­˜åˆ†é…çš„å®ç°ï¼Œä¼šè¢«ç”¨åœ¨ç³»ç»Ÿè°ƒç”¨çš„å¤„ç†ä¸­ï¼Œå°†ç”¨æˆ·æ€çš„å†…å­˜åˆ†é…å§”æ‰˜ç»™å†…æ ¸ã€‚
- `utils/resource`ï¼šå®šä¹‰äº†ç”¨äºè¿›è¡Œ I/O æ“ä½œçš„ `Resource` ç»“æ„ä½“ï¼Œç”¨äºå¤„ç†ç”¨æˆ·æ€çš„è¯»å†™ç³»ç»Ÿè°ƒç”¨ã€‚

!!! tip "åˆ«å¿˜äº†æ›´æ–° `Cargo.toml`"

## ç”¨æˆ·ç¨‹åº

### ç¼–è¯‘ç”¨æˆ·ç¨‹åº

å¯¹äºä¸åŒçš„è¿è¡Œç¯å¢ƒï¼Œå³ä½¿æŒ‡ä»¤é›†ç›¸åŒï¼Œä¸€ä¸ªå¯æ‰§è¡Œçš„ç¨‹åºä»ç„¶æœ‰ä¸€å®šçš„å·®å¼‚ã€‚

ä¸å†…æ ¸çš„ç¼–è¯‘ç±»ä¼¼ï¼Œåœ¨ `pkg/app/config` ä¸­ï¼Œå®šä¹‰äº†ç”¨æˆ·ç¨‹åºçš„ç¼–è¯‘ç›®æ ‡ï¼Œå¹¶å®šä¹‰äº†ç›¸å…³çš„ LD é“¾æ¥è„šæœ¬ã€‚

åœ¨ `Cargo.toml` ä¸­ï¼Œä½¿ç”¨é€šé…ç¬¦å¼•ç”¨äº† `pkg/app` ä¸­çš„æ‰€æœ‰ç”¨æˆ·ç¨‹åºã€‚ç›¸å…³çš„ç¼–è¯‘è¿‡ç¨‹åœ¨å…ˆå‰ç»™å‡ºçš„ç¼–è¯‘è„šæœ¬ä¸­å‡å·²å®šä¹‰ï¼Œå¯ä»¥ç›´æ¥ç¼–è¯‘ã€‚

é€šå¸¸è€Œè¨€ï¼Œç”¨æˆ·ç¨‹åºå¹¶ä¸ç›´æ¥è‡ªè¡Œå¤„ç†ç³»ç»Ÿè°ƒç”¨ï¼Œè€Œæ˜¯ç”±ç”¨æˆ·æ€åº“æä¾›çš„å‡½æ•°è¿›è¡Œè°ƒç”¨ã€‚

åœ¨ç¼–å†™ C è¯­è¨€æ—¶ `printf`ã€`scanf` ç­‰å‡½æ•°å¹¶ä¸æ˜¯ç›´æ¥è°ƒç”¨ç³»ç»Ÿè°ƒç”¨ï¼Œä»¥ gcc on Linux çš„ä¸€èˆ¬è¡Œä¸ºä¸ºä¾‹ï¼Œè¿™äº›å‡½æ•°è¢«å®šä¹‰åœ¨ `glibc` ä¸­ï¼Œè€Œ `glibc` ä¼šå¤„ç†ç³»ç»Ÿè°ƒç”¨ã€‚ç›¸å¯¹åº”çš„ï¼Œåœ¨ Windows ä¸Šï¼Œä¹Ÿä¼šå­˜åœ¨ `msvcrt` (Microsoft Visual C Run-time) ç­‰åº“ã€‚

ä¸ºäº†è®©ç”¨æˆ·æ€ç¨‹åºæ›´å¥½åœ°ä¸ YSOS è¿›è¡Œäº¤äº’ï¼Œå¤„ç†ç¨‹åºçš„ç”Ÿå‘½å‘¨æœŸï¼Œä¾¿äºç¼–å†™ç”¨æˆ·ç¨‹åºç­‰ï¼Œéœ€è¦æä¾›ç”¨æˆ·æ€åº“ï¼Œä»¥ä¾¿ç”¨æˆ·ç¨‹åºè°ƒç”¨ã€‚

ç”¨æˆ·æ€åº“è¢«å®šä¹‰åœ¨ `pkg/lib` ä¸­ï¼Œåœ¨ç”¨æˆ·ç¨‹åºä¸­ï¼Œç¼–è¾‘ `Cargo.toml`ï¼Œä½¿ç”¨å¦‚ä¸‹æ–¹å¼å¼•ç”¨ç”¨æˆ·åº“ï¼š

```rust
[dependencies]
lib = { path="../../lib", package="yslib"}
```

ä¸€ä¸ªç®€å•çš„ç”¨æˆ·ç¨‹åºç¤ºä¾‹å¦‚ä¸‹æ‰€ç¤ºï¼ŒåŒæ ·å­˜åœ¨äº `app/hello/src/main.rs` ä¸­ï¼š

```rust
#![no_std]
#![no_main]

use lib::*;

extern crate lib;

fn main() -> usize {
    println!("Hello, world!!!");

    233
}

entry!(main);
```

- `#![no_std]` è¡¨ç¤ºä¸ä½¿ç”¨æ ‡å‡†åº“ï¼Œrust å¹¶æ²¡æœ‰æ”¯æŒ YSOS çš„æ ‡å‡†åº“ï¼Œéœ€è¦æˆ‘ä»¬è‡ªè¡Œå®ç°ã€‚
- `#![no_main]` è¡¨ç¤ºä¸ä½¿ç”¨æ ‡å‡†çš„ `main` å‡½æ•°å…¥å£ï¼Œè€Œæ˜¯ä½¿ç”¨ `entry!` å®å®šä¹‰çš„å…¥å£å‡½æ•°ã€‚

`entry!` å®çš„å®šä¹‰å¦‚ä¸‹ï¼š

```rust
#[macro_export]
macro_rules! entry {
    ($fn:ident) => {
        #[export_name = "_start"]
        pub extern "C" fn __impl_start() {
            let ret = $fn();
            // FIXME: after syscall, add lib::sys_exit(ret);
            loop {}
        }
    };
}
```

åœ¨ `__impl_start` å‡½æ•°ä¸­ï¼Œè°ƒç”¨ç”¨æˆ·ç¨‹åºçš„ `main` å‡½æ•°ï¼Œå¹¶åœ¨ç”¨æˆ·ç¨‹åºé€€å‡ºåï¼Œè¿›å…¥æ­»å¾ªç¯ã€‚åœ¨åç»­å®Œå–„äº†è¿›ç¨‹é€€å‡ºçš„ç³»ç»Ÿè°ƒç”¨åï¼Œä½ éœ€è¦å°† `FIXME` çš„éƒ¨åˆ†æ›¿æ¢ä¸ºæ­£ç¡®çš„ç³»ç»Ÿè°ƒç”¨ã€‚

!!! note "å…³äº `libc` çš„å¤„ç†"

    åœ¨ Linux ä¸­ï¼Œä¸€ä¸ªæ­£å¸¸çš„ç”¨æˆ·ç¨‹åºåœ¨ç¼–è¯‘åä¹Ÿä¸ä¼šç›´æ¥æ‰§è¡Œ `main` å‡½æ•°ï¼Œè€Œæ˜¯æ‰§è¡Œ `_start` å‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°ä¼šé€šè¿‡è°ƒç”¨ `__libc_start_main`ï¼Œæœ€ç»ˆé€šè¿‡ `__libc_stop_main`ã€`__exit` ç­‰ä¸€ç³»åˆ—å‡½æ•°ï¼Œå‡†å¤‡å¥½åº”ç”¨ç¨‹åºéœ€è¦æ‰§è¡Œçš„ç¯å¢ƒï¼Œå¹¶åœ¨ç¨‹åºé€€å‡ºåè¿›è¡Œä¸€äº›åç»­çš„å·¥ä½œã€‚

!!! success "é˜¶æ®µæ€§æˆæœ"

    åœ¨ä¸€åˆ‡é…ç½®é¡ºåˆ©ä¹‹åï¼Œåº”å½“å¯ä»¥ä½¿ç”¨ `cargo build` åœ¨ç”¨æˆ·ç¨‹åºç›®å½•ä¸­æ­£ç¡®åœ°ç¼–è¯‘ç”¨æˆ·ç¨‹åºã€‚

### åŠ è½½ç¨‹åºæ–‡ä»¶

åœ¨æˆåŠŸç¼–è¯‘äº†ç”¨æˆ·ç¨‹åºåï¼Œç”¨æˆ·ç¨‹åºå°†è¢«è„šæœ¬ç§»åŠ¨åˆ° `esp/APP` ç›®å½•ä¸‹ï¼Œå¹¶**ä»¥æ–‡ä»¶å¤¹å‘½å**ã€‚è¾…åŠ©è„šæœ¬ `ysos.py` åŠŸèƒ½å·²å®Œå¤‡ï¼Œä¸è¿‡ `Makefile` éœ€è¦æ ¹æ®æ­¤æ¬¡å®éªŒè¿›è¡Œæ›´æ–°ã€‚

> ç”±äº FAT16 æ–‡ä»¶ç³»ç»Ÿçš„é™åˆ¶ï¼Œæ–‡ä»¶åé•¿åº¦ä¸èƒ½è¶…è¿‡ 8 ä¸ªå­—ç¬¦ï¼Œæ‰€ä»¥å»ºè®®ä½¿ç”¨ç®€çŸ­çš„æ–‡ä»¶å¤¹åã€‚

!!! note "å…³äºç”¨æˆ·ç¨‹åºçš„å‘½å"

    ç”±äºçµæ´»æ€§é™åˆ¶ï¼Œ`Makefile` è¢«è®¾è®¡ä¸º**åªèƒ½å°†åŒ…åï¼ˆ`Cargo.toml` ä¸­çš„ `package.name`ï¼‰ä¸º `ysos_$$app` ä¸”æ–‡ä»¶å¤¹åç§°ä¸º `$$app`** çš„ç”¨æˆ·ç¨‹åºå¤åˆ¶åˆ° `esp/APP` ç›®å½•ä¸‹ï¼Œå…¶ä»–çš„å‘½åå°†ä¼šé¢ä¸´é”™è¯¯ã€‚

    è€Œ `ysos.py` è„šæœ¬åˆ™ä¼šå°è¯•è¯»å– `Cargo.toml` çš„é…ç½®ï¼Œæ ¹æ®**å¯¹åº”åç§°**çš„ç›´æ¥å¤åˆ¶åˆ° `esp/APP` ç›®å½•ä¸‹çš„**æ–‡ä»¶å¤¹åç§°**ï¼Œå› æ­¤æ¯” `Makefile` æ›´åŠ çµæ´»ã€‚

    å¦‚æœä½ æœ‰å…¶ä»–éœ€æ±‚ï¼Œä¹Ÿå¯ä»¥è‡ªè¡Œä¿®æ”¹è¾…åŠ©è„šæœ¬ï¼Œä½¿å¾—ç¼–è¯‘æµç¨‹çš„æ­£ç¡®æ‰§è¡Œã€‚

ç›®å‰çš„å†…æ ¸å°šä¸å…·å¤‡è®¿é—®ç£ç›˜å’Œæ–‡ä»¶ç³»ç»Ÿï¼Œå¹¶å°†å®ƒä»¬è¯»å–åŠ è½½çš„èƒ½åŠ›ï¼ˆå°†ä¼šåœ¨å®éªŒå…­ä¸­å®ç°ï¼‰ï¼Œå› æ­¤éœ€è¦å¦è¾Ÿè¹Šå¾„ï¼šåœ¨ bootloader ä¸­å°†ç¬¦åˆæ¡ä»¶çš„ç”¨æˆ·ç¨‹åºåŠ è½½åˆ°å†…å­˜ä¸­ï¼Œå¹¶å°†å®ƒä»¬äº¤ç»™å†…æ ¸ï¼Œç”¨äºç”Ÿæˆç”¨æˆ·è¿›ç¨‹ã€‚

!!! note "ä¿®æ”¹å†…æ ¸é…ç½®æ–‡ä»¶"

    è¿™å°±æ˜¯ lab 1 ä¸­ `Config` å«æœ‰ `load_apps` çš„åŸå› ã€‚

    æœ¬æ¬¡å®éªŒä½ åº”å½“åœ¨ `pkg/kernel/config/boot.conf` ä¸­ï¼Œå°† `load_apps` è®¾ç½®ä¸º `true`ã€‚

ä¸ºäº†å­˜å‚¨ç”¨æˆ·ç¨‹åºçš„ç›¸å…³ä¿¡æ¯ï¼Œåœ¨ `pkg\boot\src\lib.rs` ä¸­ï¼Œå®šä¹‰ä¸€ä¸ª `App` ç»“æ„ä½“ï¼Œå¹¶æ·»åŠ â€œå·²åŠ è½½çš„ç”¨æˆ·ç¨‹åºâ€å­—æ®µåˆ° `BootInfo` ç»“æ„ä½“ä¸­ï¼š

```rust
use arrayvec::{ArrayString, ArrayVec};

/// App information
pub struct App<'a> {
    /// The name of app
    pub name: ArrayString<16>,
    /// The ELF file
    pub elf: ElfFile<'a>,
}

pub type AppList = ArrayVec<App<'static>, 16>;

/// This structure represents the information that the bootloader passes to the kernel.
pub struct BootInfo {
    // ...
    // Loaded apps
    pub loaded_apps: Option<AppList>,
}
```

!!! tip "æ›´å¥½çš„ç±»å‹å£°æ˜ï¼Ÿ"

    - ä½¿ç”¨ `const` æŒ‡å®šç”¨æˆ·ç¨‹åºæ•°ç»„çš„æœ€å¤§é•¿åº¦ã€‚
    - å°è¯•å®šä¹‰ `AppListRef` ç±»å‹ï¼Œç”¨äºå­˜å‚¨ `loaded_apps.as_ref()` çš„è¿”å›å€¼ç±»å‹ï¼Œå¯ä»¥åªå…³å¿ƒ `'static` ç”Ÿå‘½å‘¨æœŸã€‚
    - æŠ›å¼ƒ `App` ç±»å‹çš„ç”Ÿå‘½å‘¨æœŸï¼Œç›´æ¥å£°æ˜ `ElfFile<'static>`ã€‚

ä¹‹åï¼Œåœ¨ `pkg/boot/src/fs.rs` ä¸­ï¼Œåˆ›å»ºå‡½æ•° `load_apps` ç”¨äºåŠ è½½ç”¨æˆ·ç¨‹åºï¼Œå¹¶å‚è€ƒ `fs.rs` ä¸­çš„å…¶ä»–å‡½æ•°ï¼Œå¤„ç†æ–‡ä»¶ç³»ç»Ÿç›¸å…³é€»è¾‘ï¼Œè¡¥å…¨ä»£ç ï¼š

```rust
/// Load apps into memory, when no fs implemented in kernel
///
/// List all file under "APP" and load them.
pub fn load_apps(bs: &BootServices) -> AppList {
    let mut root = open_root(bs);
    let mut buf = [0; 8];
    let cstr_path = uefi::CStr16::from_str_with_buf("\\APP\\", &mut buf).unwrap();

    let mut handle = { /* FIXME: get handle for \APP\ dir */ };

    let mut apps = ArrayVec::new();
    let mut entry_buf = [0u8; 0x100];

    loop {
        let info = handle
            .read_entry(&mut entry_buf)
            .expect("Failed to read entry");

        match info {
            Some(entry) => {
                let file = { /* FIXME: get handle for app binary file */ };

                if file.is_directory().unwrap_or(true) {
                    continue;
                }

                let elf = {
                    // FIXME: load file with `load_file` function
                    // FIXME: convert file to `ElfFile`
                };

                let mut name = ArrayString::<16>::new();
                entry.file_name().as_str_in_buf(&mut name).unwrap();

                apps.push(App { name, elf });
            }
            None => break,
        }
    }

    info!("Loaded {} apps", apps.len());

    apps
}
```

åœ¨ `boot/src/main.rs` ä¸­ï¼Œ`main` å‡½æ•°ä¸­åŠ è½½å¥½å†…æ ¸çš„ `ElfFile` ä¹‹åï¼Œæ ¹æ®é…ç½®é€‰é¡¹æŒ‰éœ€åŠ è½½ç”¨æˆ·ç¨‹åºï¼Œå¹¶å°†å…¶ä¿¡æ¯ä¼ é€’ç»™å†…æ ¸ï¼š

```rust
// ...

let apps = if config.load_apps {
    info!("Loading apps...");
    Some(load_apps(system_table.boot_services()))
} else {
    info!("Skip loading apps");
    None
};

// ...

// construct BootInfo
let bootinfo = BootInfo {
    // ...
    loaded_apps: apps,
};
```

ä¿®æ”¹ `ProcessManager` çš„å®šä¹‰ä¸åˆå§‹åŒ–é€»è¾‘ï¼Œå°† `AppList` æ·»åŠ åˆ° `ProcessManager` ä¸­ï¼š

```rust
pub struct ProcessManager {
    // ...
    app_list: boot::AppListRef,
}
```

æœ€åä¿®æ”¹ `kernel/src/proc/mod.rs` çš„ `init` å‡½æ•°ï¼š

```rust
/// init process manager
pub fn init(boot_info: &'static boot::BootInfo) {
    // ...
    let app_list = boot_info.loaded_apps.as_ref();
    manager::init(kproc, app_list);
}
```

ä¹‹åï¼Œåœ¨ `kernel/src/proc/mod.rs` ä¸­ï¼Œå®šä¹‰ä¸€ä¸ª `list_app` å‡½æ•°ï¼Œç”¨äºåˆ—å‡ºå½“å‰ç³»ç»Ÿä¸­çš„æ‰€æœ‰ç”¨æˆ·ç¨‹åºå’Œç›¸å…³ä¿¡æ¯ï¼š

```rust
pub fn list_app() {
    x86_64::instructions::interrupts::without_interrupts(|| {
        let app_list = get_process_manager().app_list();
        if app_list.is_none() {
            println!("[!] No app found in list!");
            return;
        }

        let apps = app_list
            .unwrap()
            .iter()
            .map(|app| app.name.as_str())
            .collect::<Vec<&str>>()
            .join(", ");

        // TODO: print more information like size, entry point, etc.

        println!("[+] App list: {}", apps);
    });
}
```

!!! success "é˜¶æ®µæ€§æˆæœ"

    åœ¨ `kernel/src/main.rs` åˆå§‹åŒ–å†…æ ¸ä¹‹åï¼Œå°è¯•è°ƒç”¨ `list_app` å‡½æ•°ï¼ŒæŸ¥çœ‹æ˜¯å¦æˆåŠŸåŠ è½½ã€‚

### ç”Ÿæˆç”¨æˆ·ç¨‹åº

åœ¨ `kernel/src/proc/mod.rs` ä¸­ï¼Œæ·»åŠ  `spawn` å’Œ `elf_spawn` å‡½æ•°ï¼Œå°† ELF æ–‡ä»¶ä»åˆ—è¡¨ä¸­å–å‡ºï¼Œå¹¶ç”Ÿæˆç”¨æˆ·ç¨‹åºï¼š

```rust
pub fn spawn(name: &str) -> Option<ProcessId> {
    let app = x86_64::instructions::interrupts::without_interrupts(|| {
        let app_list = get_process_manager().app_list()?;
        app_list.iter().find(|&app| app.name.eq(name))
    })?;

    elf_spawn(name.to_string(), &app.elf)
}

pub fn elf_spawn(name: String, elf: &ElfFile) -> Option<ProcessId> {
    let pid = x86_64::instructions::interrupts::without_interrupts(|| {
        let manager = get_process_manager();
        let process_name = name.to_lowercase();
        let parent = Arc::downgrade(&manager.current());
        let pid = manager.spawn(elf, name, Some(parent), None);

        debug!("Spawned process: {}#{}", process_name, pid);
        pid
    });

    Some(pid)
}
```

??? question "ä¸ºä»€ä¹ˆç‹¬ç«‹ä¸€ä¸ª `elf_spawn`ï¼Ÿ"

    åœ¨åç»­çš„å®éªŒä¸­ï¼Œ`spawn` å°†æ¥æ”¶ä¸€ä¸ªæ–‡ä»¶è·¯å¾„ï¼Œæ“ä½œç³»ç»Ÿéœ€è¦ä»æ–‡ä»¶ç³»ç»Ÿä¸­è¯»å–æ–‡ä»¶ï¼Œå¹¶å°†å…¶åŠ è½½åˆ°å†…å­˜ä¸­ã€‚

    é€šè¿‡å°† `elf_spawn` ç‹¬ç«‹å‡ºæ¥ï¼Œå¯ä»¥åœ¨åç»­å®éªŒä¸­ç›´æ¥å¯¹æ¥åˆ°æ–‡ä»¶ç³»ç»Ÿçš„è¯»å–ç»“æœï¼Œè€Œæ— éœ€ä¿®æ”¹åç»­ä»£ç ã€‚

åœ¨ `ProcessManager` ä¸­ï¼Œå®ç° `spawn` å‡½æ•°ï¼š

```rust
pub fn spawn(
    &self,
    elf: &ElfFile,
    name: String,
    parent: Option<Weak<Process>>,
    proc_data: Option<ProcessData>,
) -> ProcessId {
    let kproc = self.get_proc(&KERNEL_PID).unwrap();
    let page_table = kproc.read().clone_page_table();
    let proc = Process::new(name, parent, page_table, proc_data);
    let pid = proc.pid();

    let mut inner = proc.write();
    // FIXME: load elf to process pagetable
    // FIXME: alloc new stack for process
    // FIXME: mark process as ready
    drop(inner);

    trace!("New {:#?}", &proc);

    // FIXME: something like kernel thread
    pid
}
```

!!! warning "**åˆ é™¤æˆ–æ³¨é‡Šä¸Šæ¬¡å®éªŒä¸­æœ‰å…³å†…æ ¸çº¿ç¨‹çš„ä»£ç ï¼Œé˜²æ­¢åç»­ä¿®æ”¹åçš„è¿›ç¨‹æ¨¡å‹åœ¨æ‰§è¡Œå†…æ ¸çº¿ç¨‹æ—¶é‡åˆ°æ„å¤–çš„é—®é¢˜ã€‚**"

åœ¨åŠ è½½çš„è¿‡ç¨‹ä¸­ï¼Œä½ å¯ä»¥å¤ç”¨ `elf::load_elf` å‡½æ•°ã€‚å¯ä»¥é€šè¿‡ä¸ºå®ƒæ·»åŠ å‚æ•°çš„æ–¹å¼ï¼Œæ§åˆ¶è¿™ä¸€æ˜ å°„çš„å†…å®¹æ˜¯å¦å¯ä»¥è¢«ç”¨æˆ·æƒé™ï¼ˆRing 3ï¼‰ä»£ç è®¿é—®ã€‚

```rust
pub fn load_elf(
    elf: &ElfFile,
    physical_offset: u64,
    page_table: &mut impl Mapper<Size4KiB>,
    frame_allocator: &mut impl FrameAllocator<Size4KiB>,
    user_access: bool
) -> /* return type */ {
    // FIXME: just like kernel's load_elf
}
```

åœ¨æ˜ å°„é¡µé¢æ—¶ï¼Œæ ¹æ®æ­¤å‚æ•°å†³å®šæ˜¯å¦æ·»åŠ  `USER_ACCESSIBLE` æ ‡å¿—ä½ï¼š

```rust
if user_access {
    page_table_flags |= PageTableFlags::USER_ACCESSIBLE;
}
```

è¿™ä¸€æ ‡å¿—ä½åªåº”å½“ä¸ºç”¨æˆ·è¿›ç¨‹æ‰€ä½¿ç”¨ï¼Œå†…æ ¸ç›¸å…³ä»£ç ä¸åº”å½“æ‹¥æœ‰è¿™ä¸€æƒé™ã€‚ç”±äºç”¨æˆ·ç¨‹åºæ˜¯ä¸å¯ä¿¡çš„ï¼Œéœ€è¦ä»¥æ­¤é˜²æ­¢ç”¨æˆ·æ€ç¨‹åºè®¿é—®å†…æ ¸çš„å†…å­˜ç©ºé—´ã€‚

!!! note "**å¯¹äºç”¨æˆ·è¿›ç¨‹è€Œè¨€ï¼Œä¸å†ä¸å†…æ ¸å…±äº«é¡µè¡¨ï¼Œè€Œæ˜¯é€šè¿‡å…‹éš†å†…æ ¸é¡µè¡¨è·å–äº†è‡ªå·±çš„é¡µè¡¨ã€‚è¿™æ„å‘³ç€å¯ä»¥ä¸ºæ¯ä¸ªç”¨æˆ·è¿›ç¨‹åˆ†é…åŒæ ·çš„æ ˆåœ°å€ï¼Œè€Œä¸ä¼šç›¸äº’å¹²æ‰°ã€‚**"

éœ€è¦åœ¨ GDT ä¸­ä¸º Ring 3 çš„ä»£ç æ®µå’Œæ•°æ®æ®µæ·»åŠ å¯¹åº”çš„é€‰æ‹©å­ï¼Œåœ¨åˆå§‹åŒ–æ ˆå¸§çš„æ—¶å€™å°†å…¶ä¼ å…¥ã€‚åœ¨ `kernel/src/memory/gdt.rs` ä¸­ï¼Œä½ å¯ä»¥ä½¿ç”¨å¦‚ä¸‹æ–¹å¼æ·»åŠ ï¼š

```rust
lazy_static! {
    static ref GDT: /* your type */ = {
        let mut gdt = GlobalDescriptorTable::new();
        // ...
        let user_code_selector = gdt.add_entry(Descriptor::user_code_segment());
        let user_data_selector = gdt.add_entry(Descriptor::user_data_segment());
        // ...
    };
}
```

ä¹‹åå°†å…¶é€šè¿‡åˆé€‚çš„æ–¹å¼æš´éœ²å‡ºæ¥ï¼Œä»¥ä¾›æ ˆå¸§åˆå§‹åŒ–æ—¶ä½¿ç”¨ï¼š

```rust
pub fn init_stack_frame(&mut self, entry: VirtAddr, stack_top: VirtAddr) {
    // ...
    let selector = get_user_selector(); // FIXME: implement this function

    self.value.stack_frame.code_segment = selector.user_code_selector.0 as u64;
    self.value.stack_frame.stack_segment = selector.user_data_selector.0 as u64;
    // ...
}
```

!!! tip "ä¸€äº›æç¤º"

    - ä¸å†…æ ¸ç±»ä¼¼ï¼Œä½¿ç”¨ `elf.header.pt2.entry_point()` è·å– ELF æ–‡ä»¶çš„å…¥å£åœ°å€ã€‚
    - æˆ–è®¸å¯ä»¥åœ¨ `ProcessInner` ä¸­å®ç°ä¸€ä¸ª `load_elf` å‡½æ•°ï¼Œæ¥å¤„ç†ä»£ç æ®µæ˜ å°„ç­‰å†…å®¹ã€‚
    - è®°å¾—ä¸ºè¿›ç¨‹åˆ†é…å¥½åˆé€‚çš„æ ˆç©ºé—´ï¼Œå¹¶ä½¿ç”¨ `init_stack_frame` åˆå§‹åŒ–ç¨‹åºæ ˆå’ŒæŒ‡ä»¤æŒ‡é’ˆã€‚
    - æˆ–è®¸ä½ å¯ä»¥åŒæ—¶å®ç° **åŠ åˆ†é¡¹ 1** æ‰€æè¿°çš„åŠŸèƒ½ã€‚

!!! question "é˜¶æ®µæ€§æˆæœï¼Ÿ"

    ä½†ç”±äºå¹¶æ²¡æœ‰å®ç°ä»»ä½•ç³»ç»Ÿè°ƒç”¨æœåŠ¡ï¼ˆåŒ…æ‹¬ç¨‹åºçš„é€€å‡ºã€è¾“å…¥è¾“å‡ºã€å†…å­˜åˆ†é…ç­‰ï¼‰ï¼Œå› æ­¤ä½ åœ¨åŠ è½½ç”¨æˆ·ç¨‹åºåï¼ŒåŸºæœ¬æ— æ³•è¿›è¡Œä»»ä½•æ“ä½œã€‚

    åœ¨è¿™ä¸€é˜¶æ®µï¼Œä¸ºäº†ä¸è§¦å‘å¼‚å¸¸ï¼Œä½ åªèƒ½åŠ è½½æ‰§è¡Œä¸€ä¸ªæ²¡æœ‰å…¶ä»–ä½œç”¨çš„æ­»å¾ªç¯ç¨‹åºâ€¦â€¦

    å› æ­¤ï¼Œä½ éœ€è¦åœ¨å®Œæˆåç»­ä»»åŠ¡åï¼Œæ‰èƒ½è¿›è¡Œæ•´ä½“æ€§è°ƒè¯•ã€‚

## ç³»ç»Ÿè°ƒç”¨çš„å®ç°

ä¸ºäº†ä¸ºç”¨æˆ·ç¨‹åºæä¾›æœåŠ¡ï¼Œæ“ä½œç³»ç»Ÿéœ€è¦å®ç°ä¸€ç³»åˆ—çš„ç³»ç»Ÿè°ƒç”¨ï¼Œä»è€Œä¸ºç”¨æˆ·æ€ç¨‹åºæä¾›å†…æ ¸æ€æœåŠ¡ã€‚è¿™äº›æ“ä½œåŒ…æ‹¬æ–‡ä»¶æ“ä½œã€è¿›ç¨‹æ“ä½œã€å†…å­˜æ“ä½œç­‰ï¼Œç›¸å…³çš„æŒ‡ä»¤ä¸€èˆ¬éœ€è¦æ›´é«˜çš„æƒé™ï¼ˆç›¸å¯¹äºç”¨æˆ·ç¨‹åºï¼‰æ‰èƒ½æ‰§è¡Œã€‚

### è°ƒç”¨çº¦å®š

ç³»ç»Ÿè°ƒç”¨ä¸€èˆ¬æœ‰ç³»ç»Ÿè°ƒç”¨å·ã€å‚æ•°ã€è¿”å›å€¼ç­‰è°ƒç”¨çº¦å®šï¼Œä¸åŒçš„ä¸Šä¸‹æ–‡å‚æ•°å¯¹åº”çš„ç³»ç»Ÿè°ƒç”¨çš„è¡Œä¸ºå­˜åœ¨ä¸åŒã€‚

ä»¥ x86_64 çš„ Linux ä¸ºä¾‹ï¼Œç³»ç»Ÿè°ƒç”¨çš„éƒ¨åˆ†è°ƒç”¨çº¦å®šå¦‚ä¸‹æ‰€ç¤ºï¼š

- ç³»ç»Ÿè°ƒç”¨å·é€šè¿‡ `rax` å¯„å­˜å™¨ä¼ é€’
- å‚æ•°é€šè¿‡ `rdi`ã€`rsi`ã€`rdx`ã€`r10`ã€`r8`ã€`r9` å¯„å­˜å™¨ä¼ é€’
- å‚æ•°æ•°é‡å¤§äº 6 æ—¶ï¼Œé€šè¿‡æ ˆä¼ é€’
- è¿”å›å€¼é€šè¿‡ `rax` å¯„å­˜å™¨ä¼ é€’

!!! tip "åœ¨ç³»ç»Ÿè°ƒç”¨ä¸­ï¼Œç”±äº `rcx` å¯„å­˜å™¨æœ‰å…¶ä»–ç”¨é€”ï¼Œå› æ­¤ä½¿ç”¨ `r10` å¯„å­˜å™¨ä»£æ›¿å‡½æ•°è°ƒç”¨çº¦å®š `__fastcall` ä¸­çš„ `rcx` å¯„å­˜å™¨ã€‚"

å®éªŒå®ç°ä¸­å¹¶ä¸éœ€è¦é‚£ä¹ˆå¤šçš„ç³»ç»Ÿè°ƒç”¨å‚æ•°ï¼Œåœ¨ `src/interrupt/syscall/mod.rs` ä¸­å®šä¹‰äº†ä¸€ä¸ªç”¨äºå­˜å‚¨ç³»ç»Ÿè°ƒç”¨å‚æ•°çš„ç»“æ„ä½“ `SyscallArgs`ï¼š

```rust
#[derive(Clone, Debug)]
pub struct SyscallArgs {
    pub syscall: Syscall,
    pub arg0: usize,
    pub arg1: usize,
    pub arg2: usize,
}
```

ä¹‹ååœ¨åˆ†å‘å™¨å‡½æ•° `dispatcher` ä¸­ï¼Œæ„é€  `SyscallArgs` ç»“æ„ä½“ï¼Œå°Šé‡ä¹ æƒ¯æ€§å†™æ³•ï¼Œä½¿ç”¨ `rdi` / `rsi` / `rdx` å¯„å­˜å™¨ä¼ é€’ç³»ç»Ÿè°ƒç”¨å‚æ•°ï¼Œä¹‹åè°ƒç”¨ç›¸åº”çš„å¤„ç†å‡½æ•°ã€‚

```rust
pub fn dispatcher(context: &mut ProcessContext) {
    let args = super::syscall::SyscallArgs::new(
        Syscall::try_from(context.regs.rax).unwrap_or_default(),
        context.regs.rdi,
        context.regs.rsi,
        context.regs.rdx,
    );

    match args.syscall {
        // ...
    }
}
```

ä¸ºäº†èƒ½åœ¨ç”¨æˆ·åº“ï¼ˆè°ƒç”¨ç³»ç»Ÿè°ƒç”¨ä¾§ï¼‰å’Œå†…æ ¸æ€ï¼ˆå¤„ç†ç³»ç»Ÿè°ƒç”¨ä¾§ï¼‰ä¹‹é—´è¾¾æˆç³»ç»Ÿè°ƒç”¨å·çš„ä¸€è‡´æ€§ï¼Œåœ¨ `pkg/syscall` ä¸­å®šä¹‰äº†ä¸€ä¸ª `Syscall` æšä¸¾ï¼Œç”¨äºå­˜å‚¨ç³»ç»Ÿè°ƒç”¨å·ã€‚

```rust
#[repr(usize)]
#[derive(Clone, Debug, TryFromPrimitive)]
pub enum Syscall {
    Read = 0,
    Write = 1,

    Spawn = 59,
    Exit = 60,
    WaitPid = 61,

    ListApp = 65531,
    Stat = 65532,
    Allocate = 65533,
    Deallocate = 65534,

    #[num_enum(default)]
    Unknown = 65535,
}
```

ç”±äºä¸€äº›é¢å¤–çš„æ‰§å¿µï¼Œè¿™é‡Œçš„è¯»å†™ã€è¿›ç¨‹æ“ä½œçš„ç³»ç»Ÿè°ƒç”¨å·åŸºæœ¬ä¸ Linux ä¸­åŠŸèƒ½ç±»ä¼¼çš„ç³»ç»Ÿè°ƒç”¨å·ä¸€è‡´ï¼Œè€Œæœ‰äº›ç³»ç»Ÿè°ƒç”¨å·åˆ™æ˜¯è‡ªå®šä¹‰çš„ã€‚

- `ListApp` ç”¨äºåˆ—å‡ºå½“å‰ç³»ç»Ÿä¸­çš„æ‰€æœ‰ç”¨æˆ·ç¨‹åºï¼Œç”±äºå°šä¸ä¼šè¿›è¡Œæ–‡ä»¶ç³»ç»Ÿçš„å®ç°ï¼Œå› æ­¤éœ€è¦è¿™æ ·ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨æ¥è·å–ç”¨æˆ·ç¨‹åºçš„ä¿¡æ¯ã€‚
- `Stat` ç”¨äºè·å–ç³»ç»Ÿä¸­çš„ä¸€äº›ç»Ÿè®¡ä¿¡æ¯ï¼Œä¾‹å¦‚å†…å­˜ä½¿ç”¨æƒ…å†µã€è¿›ç¨‹åˆ—è¡¨ç­‰ï¼Œç”¨äºè°ƒè¯•å’Œç›‘æ§ã€‚
- `Allocate/Deallocate` ç”¨äºåˆ†é…å’Œé‡Šæ”¾å†…å­˜ã€‚åœ¨å½“å‰æ²¡æœ‰å®Œæ•´çš„ç”¨æˆ·æ€å†…å­˜åˆ†é…æ”¯æŒçš„æƒ…å†µä¸‹ï¼Œå¯ä»¥åˆ©ç”¨ç³»ç»Ÿè°ƒç”¨å°†å…¶å§”æ‰˜ç»™å†…æ ¸æ¥å®Œæˆã€‚

### è½¯ä¸­æ–­å¤„ç†

åœ¨ [CPU ä¸­æ–­å¤„ç†](../../wiki/interrupts.md)ä¸­ä»‹ç»äº†è½¯ä»¶ä¸­æ–­çš„ä½¿ç”¨æ–¹å¼å’Œç”¨é€”ï¼Œåœ¨ Linux ä¸­ï¼Œä¸€ä¸ªåŸºäºä¸­æ–­çš„ç³»ç»Ÿè°ƒç”¨å¯ä»¥ç”¨å¦‚ä¸‹çš„æ±‡ç¼–å®ç°ï¼š

```c
int _start() {
    __asm__(
        // å‡†å¤‡ç³»ç»Ÿè°ƒç”¨å‚æ•°
        "xor    %eax,%eax\n"
        "push   %eax\n"
        "push   $0x68732f2f\n"
        "push   $0x6e69622f\n"
        "mov    %esp,%ebx\n"
        "push   %eax\n"
        "push   %ebx\n"
        "mov    %esp,%ecx\n"
        "mov    $0xb,%al\n"

        // ç³»ç»Ÿè°ƒç”¨ä¸­æ–­
        "int    $0x80\n"
    );
}
```

??? note "å¦‚æœæƒ³è¦æµ‹è¯•ï¼Œéœ€è¦ç¼–è¯‘ä¸º 32 ä½çš„å¯æ‰§è¡Œæ–‡ä»¶"

    ä½ å¯ä»¥ä½¿ç”¨å¦‚ä¸‹çš„å‘½ä»¤ç¼–è¯‘ï¼š

    ```bash
    gcc syscall.c -o syscall -m32 -nostdlib -nodefaultlibs -fno-exceptions -no-pie
    ```

    ä½ å¯ä»¥ä½¿ç”¨ `objdump -d syscall` æ¥æŸ¥çœ‹ç¼–è¯‘åçš„æ±‡ç¼–ä»£ç ã€‚

    ä½ å¯ä»¥åœ¨ x86_64 çš„æœºå™¨ä¸Šç›´æ¥è¿è¡Œå®ƒã€‚

    è¿™æ®µæ±‡ç¼–çš„ä»£ç çš„ä½œç”¨æ˜¯è°ƒç”¨ `execve` ç³»ç»Ÿè°ƒç”¨ï¼Œæ‰§è¡Œ `/bin/sh`ï¼Œä¹Ÿå³ä¸€æ®µ `shellcode`ã€‚

!!! question "`int 0x80`ã€`sysenter` å’Œ `syscall` çš„åŒºåˆ«ï¼Ÿ"

    `int 0x80` æ˜¯åŸºäºä¸­æ–­çš„ç³»ç»Ÿè°ƒç”¨å®ç°ï¼Œé€šå¸¸åœ¨æ—©æœŸçš„ 32 ä½ x86 ç³»ç»Ÿä¸­ä½¿ç”¨ã€‚

    ç”±äºè½¯ä¸­æ–­ä¿å­˜ã€æ¢å¤ç°åœºã€æŸ¥è¯¢ä¸­æ–­å‘é‡è¡¨ç­‰æ“ä½œå¯¹äºç³»ç»Ÿè°ƒç”¨è¿›å…¥å†…æ ¸æ€æ¥è¯´è¿‡äº**é‡**äº†ï¼Œä¸€å®šç¨‹åº¦ä¸Šå½±å“ CPU æ‰§è¡Œç”¨æˆ·ç¨‹åºçš„æ•ˆç‡ï¼Œ`sysenter` å’Œ `syscall` è¢«å¼•å…¥ã€‚

    å®ƒä»¬ä¸“é—¨ç”¨äºç³»ç»Ÿè°ƒç”¨ï¼Œ`sysenter` ç”¨äº 32 ä½ç³»ç»Ÿï¼Œ`syscall` ç”¨äº 64 ä½ç³»ç»Ÿã€‚å®ƒä»¬ä¸æŸ¥è¯¢ä¸­æ–­æè¿°ç¬¦è¡¨ï¼Œé€šè¿‡ç›´æ¥è®¿é—®æŸäº›ç‰¹æ®Šå¯„å­˜å™¨ç­‰æŒ‡ä»¤å’Œ CPU è®¾è®¡ä¸Šçš„ä¼˜åŒ–ï¼Œä»è€Œå‡å°‘äº†ç³»ç»Ÿè°ƒç”¨çš„å¼€é”€ã€‚

    ä½ å¯ä»¥æŸ¥é˜…èµ„æ–™ï¼Œäº†è§£å®ƒä»¬çš„å…·ä½“å®ç°å’Œä½¿ç”¨æ–¹å¼ã€‚ä½†åœ¨æœ¬å®éªŒä¸­ï¼Œä¸éœ€è¦è€ƒè™‘ä¸­æ–­å¸¦æ¥çš„æ€§èƒ½æŸè€—ï¼Œå®ç°æ—¶ä½¿ç”¨ä¸­æ–­è¿›è¡Œç³»ç»Ÿè°ƒç”¨å³å¯ã€‚

åœ¨ `src/interrupt/syscall/mod.rs` ä¸­ï¼Œè¡¥å…¨ä¸­æ–­æ³¨å†Œå‡½æ•°ï¼Œ**å¹¶åœ¨åˆé€‚çš„åœ°æ–¹è°ƒç”¨å®ƒ**ï¼š

1. åœ¨ `idt` çš„åˆå§‹åŒ–ä¸­ï¼Œæ³¨å†Œ `0x80` å·ä¸­æ–­çš„å¤„ç†å‡½æ•°ä¸º `syscall_handler`ã€‚*`int 0x80` å¹¶é Irq ä¸­æ–­ï¼Œç›´æ¥ä½¿ç”¨ `consts::Interrupts::Syscall` å³å¯ã€‚*
2. ä¸æ—¶é’Ÿä¸­æ–­ç±»ä¼¼ï¼Œæˆ–è®¸ä¸ºç³»ç»Ÿè°ƒç”¨å‡†å¤‡ä¸€ä¸ªç‹¬ç«‹çš„æ ˆæ˜¯ä¸ªå¥½ä¸»æ„ï¼Ÿ
3. ä½¿ç”¨ `set_privilege_level` è®¾ç½® `DPL` ä¸º `3`ï¼Œä»¥ä¾¿ç”¨æˆ·æ€ç¨‹åºå¯ä»¥è§¦å‘ç³»ç»Ÿè°ƒç”¨ã€‚

## ç”¨æˆ·æ€åº“çš„å®ç°

ç”¨æˆ·æ€åº“æ˜¯ç”¨æˆ·ç¨‹åºçš„åŸºç¡€ï¼Œå®ƒæä¾›äº†ä¸€äº›åŸºç¡€çš„å‡½æ•°ï¼Œç”¨äºè°ƒç”¨ç³»ç»Ÿè°ƒç”¨ï¼Œå®ç°ä¸€äº›åŸºç¡€çš„åŠŸèƒ½ã€‚

åœ¨è¿™ä¸€éƒ¨åˆ†çš„å®ç°ä¸­ï¼Œç€é‡å®ç°äº† `read` å’Œ `write` ç³»ç»Ÿè°ƒç”¨çš„å°è£…å’Œå†…æ ¸ä¾§çš„å®ç°ï¼Œå¹¶é€šè¿‡å†…å­˜åˆ†é…ã€é‡Šæ”¾çš„ç³»ç»Ÿè°ƒç”¨ï¼Œç»™äºˆç”¨æˆ·æ€ç¨‹åºåŠ¨æ€å†…å­˜åˆ†é…çš„èƒ½åŠ›ã€‚

### åŠ¨æ€å†…å­˜åˆ†é…

ä¸ºäº†æ–¹ä¾¿ç”¨æˆ·æ€ç¨‹åºä½¿ç”¨åŠ¨æ€å†…å­˜åˆ†é…ï¼Œè€Œä¸æ˜¯åŸºäº `mmap` ç­‰æ–¹å¼è¿›è¡Œå®Œå…¨ç”¨æˆ·æ€çš„åŠ¨æ€å†…å­˜ç®¡ç†ï¼Œé€‰æ‹©ä½¿ç”¨ç³»ç»Ÿè°ƒç”¨çš„æ–¹å¼ï¼Œå°†å†…å­˜åˆ†é…çš„ä»»åŠ¡å§”æ‰˜ç»™å†…æ ¸å®Œæˆã€‚

ä¸å†…æ ¸å †ç±»ä¼¼ï¼Œåœ¨ `src/memory/user.rs` ä¸­ï¼Œå®šä¹‰äº†ç”¨æˆ·æ€çš„å †ã€‚

ä¸å†…æ ¸ä½¿ç”¨ `static` åœ¨å†…æ ¸ `bss` æ®µå£°æ˜å†…å­˜ç©ºé—´ä¸åŒï¼Œç”±äºåœ¨é¡µè¡¨æ˜ å°„æ—¶éœ€æ·»åŠ  `USER_ACCESSIBLE` æ ‡å¿—ä½ï¼Œ**ç”¨æˆ·æ€å †éœ€è¦é‡‡ç”¨å†…æ ¸é¡µé¢åˆ†é…çš„èƒ½åŠ›å®Œæˆ**ã€‚å…¶æ¬¡éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä¸ºäº†è°ƒè¯•å’Œå®‰å…¨æ€§è€ƒé‡ï¼Œè¿™éƒ¨åˆ†å†…å­˜è¿˜éœ€è¦ `NO_EXECUTE` æ ‡å¿—ä½ã€‚

æœ‰å…³ç”¨æˆ·æ€å †åˆå§‹åŒ–çš„è¿‡ç¨‹éœ€è¦è¡¥å…¨éƒ¨åˆ†ä»£ç ï¼ŒæŒ‡å®šåˆé€‚çš„é¡µé¢èŒƒå›´ï¼Œåˆ†é…å¹¶æ˜ å°„ç›¸å…³çš„é¡µè¡¨ï¼Œä½ å¯ä»¥å‚è€ƒã€ä½¿ç”¨å¹¶ä¿®æ”¹ `elf::map_range` å®Œæˆè¿™é‡Œçš„åˆå§‹åŒ–ã€‚

!!! question "å†…å­˜å®‰å…¨ï¼Ÿ"

    è¿™é‡Œçš„å®ç°æ˜¯ä¸å¤Ÿå®‰å…¨çš„ï¼Œå…±äº«ç”¨æˆ·æ€å †æ„å‘³ç€ç”¨æˆ·ç¨‹åºå¯ä»¥ä»»æ„è¯»å–è®¿é—®å…¶ä»–ç”¨æˆ·è¿›ç¨‹çš„å †ç©ºé—´ã€‚

    ä¸è¿‡è¿™æ ·çš„å®ç°å¯ä»¥å¤§å¹…ç®€åŒ–ç”¨æˆ·æ€åº“çš„ç›¸å…³å®ç°ï¼Œåœ¨èƒ½ä¸”ä»…èƒ½è¿è¡Œè‡ªå·±çš„ç¨‹åºã€å®Œæˆå®éªŒæ–¹é¢ï¼Œè¿™æ ·çš„é€‰æ‹©æ˜¯å¾ˆåˆé€‚çš„ã€‚

åœ¨ç³»ç»Ÿè°ƒç”¨çš„å®ç°æ–¹é¢ï¼Œç»™å‡ºçš„ä»£ç ä¸­å·²åŒ…å«ï¼Œå¯ä»¥å‚è€ƒå®ƒä»¬çš„å†…å®¹è¿›è¡Œå…¶ä»–ç³»ç»Ÿè°ƒç”¨åŠŸèƒ½çš„å®ç°ã€‚

### æ ‡å‡†è¾“å…¥è¾“å‡º

ä¸ºäº†åœ¨ç³»ç»Ÿè°ƒç”¨ä¸­å®ç°åŸºç¡€çš„è¯»å†™æ“ä½œï¼Œä»£ç ä¸­å®šä¹‰äº†ä¸€ä¸ª `Resource` æšä¸¾ï¼Œå¹¶å€Ÿç”¨ Linux ä¸­â€œæ–‡ä»¶æè¿°ç¬¦â€çš„ç±»ä¼¼æ¦‚å¿µï¼Œå°†å…¶å­˜å‚¨åœ¨è¿›ç¨‹ä¿¡æ¯ä¸­ã€‚

åœ¨ `src/proc/data.rs` ä¸­ï¼Œä¿®æ”¹ `ProcessData` ç»“æ„ä½“ï¼Œç±»ä¼¼äºç¯å¢ƒå˜é‡çš„å®šä¹‰ï¼Œæ·»åŠ ä¸€ä¸ªâ€œæ–‡ä»¶æè¿°ç¬¦è¡¨â€ï¼š

```rust
pub(super) file_handles: Arc<RwLock<BTreeMap<u8, Resource>>>
```

åœ¨ `ProcessData` çš„ `default` å‡½æ•°ä¸­ï¼Œåˆå§‹åŒ–æ­¤è¡¨ï¼Œå¹¶æ·»åŠ æ ‡å‡†è¾“å…¥è¾“å‡ºçš„èµ„æºï¼š

```rust
let mut file_handles = BTreeMap::new();

// stdin, stdout, stderr
file_handles.insert(0, Resource::Console(StdIO::Stdin));
file_handles.insert(1, Resource::Console(StdIO::Stdout));
file_handles.insert(2, Resource::Console(StdIO::Stderr));
```

ä¹‹åæ·»åŠ  `handle` å‡½æ•°ï¼Œç”¨äºåœ¨ç³»ç»Ÿè°ƒç”¨ä¸­æ ¹æ®æ–‡ä»¶æè¿°ç¬¦è·å–èµ„æºï¼š

```rust
pub fn handle(&self, fd: u8) -> Option<Resource> {
    self.file_handles.read().get(&fd).cloned()
}
```

ç³»ç»Ÿè°ƒç”¨æ€»æ˜¯ä¸ºå½“å‰è¿›ç¨‹æä¾›æœåŠ¡ï¼Œå› æ­¤å¯ä»¥åœ¨ `proc/mod.rs` ä¸­å¯¹ä¸€äº›æ“ä½œè¿›è¡Œå°è£…ï¼Œå°è£…è·å–å½“å‰è¿›ç¨‹ã€ä¸Šé”ç­‰æ“ä½œã€‚ä»¥è·å–å½“å‰è¿›ç¨‹çš„æ–‡ä»¶æè¿°ç¬¦è¡¨ä¸ºä¾‹ï¼š

```rust
pub fn handle(fd: u8) -> Option<Resource> {
    x86_64::instructions::interrupts::without_interrupts(|| {
        get_process_manager().current().read().handle(fd)
    })
}
```

å¯¹äº `write` ç³»ç»Ÿè°ƒç”¨ï¼Œç”¨æˆ·ç¨‹åºéœ€è¦å°†æ•°æ®å†™å…¥åˆ°èµ„æºä¸­ï¼Œå¯¹æ­¤ç³»ç»Ÿè°ƒç”¨è¿›è¡Œå¦‚ä¸‹çº¦å®šï¼š

```
fd: arg0 as u8, buf: &[u8] (ptr: arg1 as *const u8, len: arg2)
```

ä¸ºäº†ä¾¿äºç†è§£ï¼Œç»™å‡ºäº†ç”¨æˆ·ä¾§è¿›è¡Œè°ƒç”¨æ—¶çš„ç¤ºä¾‹ä»£ç ï¼Œä» `print!` çš„å®ç°å¼€å§‹ï¼š

```rust
#[macro_export]
macro_rules! print {
    ($($arg:tt)*) => ($crate::_print(format_args!($($arg)*)));
}

#[doc(hidden)]
pub fn _print(args: Arguments) {
    stdout().write(format!("{}", args).as_str());
}
```

å°†ä¼šè°ƒç”¨ `Stdout` çš„ `write` æ–¹æ³•ï¼š

```rust
impl Stdout {
    pub fn write(&self, s: &str) {
        sys_write(1, s.as_bytes());
    }
}
```

ä¼ é€’ç»™ `sys_write`ï¼Œç”±æ­¤å‡½æ•°å¯¹ä¼ å…¥çš„å‚æ•°è¿›è¡Œå¤„ç†ï¼Œå¹¶è°ƒç”¨ç³»ç»Ÿè°ƒç”¨ï¼š

```rust
pub fn sys_write(fd: u8, buf: &[u8]) -> Option<usize> {
    let ret = syscall!(
        Syscall::Write,
        fd as usize,
        buf.as_ptr() as usize,
        buf.len() as usize
    ) as isize;
    if ret.is_negative() {
        None
    } else {
        Some(ret as usize)
    }
}
```

ç³»ç»Ÿè°ƒç”¨å® `syscall!` çš„å®ç°å¦‚ä¸‹ï¼š

```rust
#[macro_export]
macro_rules! syscall {
    // ...
    ($n:expr, $a1:expr, $a2:expr, $a3:expr) => {
        $crate::macros::syscall3($n, $a1 as usize, $a2 as usize, $a3 as usize)
    };
}

#[doc(hidden)]
#[inline(always)]
pub fn syscall3(n: Syscall, arg0: usize, arg1: usize, arg2: usize) -> usize {
    let ret: usize;
    unsafe {
        asm!(
            "int 0x80", in("rax") n as usize,
            in("rdi") arg0, in("rsi") arg1, in("rdx") arg2,
            lateout("rax") ret
        );
    }
    ret
}
```

é€šè¿‡å†…è”æ±‡ç¼–çš„å½¢å¼ï¼Œå°†å‚æ•°åˆ—è¡¨å­˜å…¥å¯¹åº”çš„å¯„å­˜å™¨ä¸­ï¼Œå†è°ƒç”¨ `int 0x80` ä¸­æ–­ï¼Œè§¦å‘ç³»ç»Ÿè°ƒç”¨ã€‚

åœ¨å†…æ ¸æ­£ç¡®å“åº”ä¸­æ–­ï¼Œå¹¶è¿›è¡ŒæœåŠ¡åˆ†å‘åï¼Œè°ƒç”¨å¯¹åº”çš„æœåŠ¡å¤„ç†å‡½æ•°ã€‚

åœ¨ `interrupt/syscall/service.rs` ä¸­ï¼Œä½ éœ€è¦å®ç° `sys_write` å‡½æ•°ï¼Œç”¨äºå¤„ç† `write` ç³»ç»Ÿè°ƒç”¨ï¼Œä½¿å¾—ç”¨æˆ·ç¨‹åºå¾—ä»¥è¿›ç¨‹è¾“å‡ºï¼š

1. ä½¿ç”¨ä¸Šè¿° `proc::handle` è·å–æ–‡ä»¶æè¿°ç¬¦ï¼Œå¹¶å¤„ç† `Option`ã€‚
2. ä½¿ç”¨ `core::slice::from_raw_parts` å°†ç”¨æˆ·ç¨‹åºçš„ç¼“å†²åŒºè½¬æ¢ä¸º `&[u8]`ã€‚
3. å°†ç¼“å†²åŒºä¼ å…¥èµ„æºçš„ `write` æ–¹æ³•ä¸­ï¼Œå¹¶è¿”å›å†™å…¥çš„å­—èŠ‚æ•°ã€‚
4. åœ¨åˆ†å‘å‡½æ•°ä¸­ä½¿ç”¨ `context.set_rax` è®¾ç½®è¿”å›å€¼ï¼Œå¹¶è°ƒç”¨ `sys_write` å‡½æ•°ã€‚

!!! tip "å‚è€ƒ `sys_allocate` çš„å®ç°å’Œç›¸å…³ç”¨æˆ·ä¾§ä»£ç è¿›è¡Œå®ç°"

`sys_read` çš„å®ç°ä¸ `sys_write` ç±»ä¼¼ï¼Œä¸ºäº†æ›´å¥½çš„å…¼å®¹æ€§å’Œæ›´ä½çš„å®ç°éš¾åº¦ï¼Œåœ¨å®ç° `read` æ—¶å€™éœ€è¦æ³¨æ„å¦‚ä¸‹å‡ ç‚¹ï¼š

1. åœ¨ `Resource` ä¸­æ·»åŠ  `read` æ–¹æ³•æ—¶ï¼Œä»å†…æ ¸è¾“å…¥ç¼“å†²åŒºä¸­è¯»å–æ•°æ®å¹¶å†™å…¥åˆ°ç”¨æˆ·ç¨‹åºçš„ç¼“å†²åŒºä¸­ã€‚
2. éµå¾ªç›¸å…³åŸåˆ™ï¼Œç³»ç»Ÿè°ƒç”¨ç†è®ºä¸Šä¸åº”ç­‰å¾…ï¼Œå¦‚æœæ²¡æœ‰æ•°æ®å¯è¯»ï¼Œåº”ç«‹å³è¿”å›ã€‚
3. å¯¹ç”¨æˆ·è¾“å…¥çš„ç­‰å¾…è¡Œä¸ºåº”å½“åœ¨ç”¨æˆ·æ€ç¨‹åºä¸­å®ç°ï¼Œå¹¶åº”è¯¥æä¾›éé˜»å¡çš„è¯»å–æ–¹å¼ã€‚
4. å¯¹äºä¸€ä¸ªå›ºå®šçš„è¾“å…¥åºåˆ—ï¼Œéœ€è¦ç‰¹æ®Šå¤„ç†æ§åˆ¶å­—ç¬¦ï¼Œå¦‚å›è½¦ã€é€€æ ¼ç­‰ã€‚è¿™äº›å¤„ç†éœ€è¦åœ¨ç”¨æˆ·æ€è¿›è¡Œï¼Œå¹¶é€šè¿‡ `write` ç³»ç»Ÿè°ƒç”¨è¿›è¡Œåé¦ˆè¾“å‡ºã€‚
5. åœ¨ç”¨æˆ·æ€éœ€è¦æ§åˆ¶å¥½ç¼“å†²åŒºçš„å¤§å°ï¼Œéµå®ˆç³»ç»Ÿè°ƒç”¨è¿”å›çš„é•¿åº¦è¿›è¡Œå¤„ç†ã€‚
6. ä½¿ç”¨ `from_raw_parts_mut` å°†ç”¨æˆ·ç¨‹åºçš„ç¼“å†²åŒºè½¬æ¢ä¸º `&mut [u8]`ã€‚

### è¿›ç¨‹çš„é€€å‡º

ä¸å†…æ ¸çº¿ç¨‹é˜²æ­¢å†æ¬¡è¢«è°ƒåº¦çš„â€œé€€å‡ºâ€ä¸åŒï¼Œç”¨æˆ·ç¨‹åºçš„æ­£å¸¸ç»“æŸï¼Œéœ€è¦åœ¨ç”¨æˆ·ç¨‹åºä¸­è°ƒç”¨ `exit` ç³»ç»Ÿè°ƒç”¨ï¼Œä»¥é€šçŸ¥å†…æ ¸é‡Šæ”¾èµ„æºã€‚

ç”±äºæ­¤æ—¶é€šè¿‡ä¸­æ–­è¿›å…¥å†…æ ¸æ€ï¼Œä¸æ—¶é’Ÿä¸­æ–­ç±»ä¼¼ï¼Œæ“ä½œç³»ç»Ÿå¾—ä»¥æ§åˆ¶**é€€å‡ºä¸­æ–­æ—¶çš„ CPU ä¸Šä¸‹æ–‡**ã€‚å› æ­¤å¯ä»¥åœ¨é€€å‡ºçš„æ—¶å€™æ¸…ç†è¿›ç¨‹å ç”¨çš„èµ„æºï¼Œå¹¶è°ƒç”¨ `switch_next` å‡½æ•°ï¼Œåˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªå°±ç»ªçš„è¿›ç¨‹ã€‚

> ä¸ºäº†å®ç°çš„ç®€å•ï¼Œä¸éœ€è¦å®éªŒç¨‹åºå¼‚å¸¸é€€å‡ºçš„ç›¸å…³æƒ…å†µå¤„ç†ï¼Œå°†é”™è¯¯å±•ç¤ºå‡ºæ¥ä¹Ÿæ›´ä¾¿äºè°ƒè¯•ã€‚

ä¸ `handle` çš„å®ç°ç±»ä¼¼ï¼Œä¹Ÿå¯ä»¥é€šè¿‡åœ¨ `kernel/src/proc/mod.rs` ä¸­å®ç° `exit` å‡½æ•°ï¼Œå°è£…å¯¹åº”çš„åŠŸèƒ½ï¼Œå¹¶æš´éœ²ç»™ç³»ç»Ÿè°ƒç”¨ï¼š

```rust
pub fn exit(ret: isize, context: &mut ProcessContext) {
    x86_64::instructions::interrupts::without_interrupts(|| {
        let manager = get_process_manager();
        manager.kill_self(ret); // FIXME: implement this for ProcessManager
        manager.switch_next(context);
    })
}
```

!!! tip "å¢åŠ ä»£ç é‡ç”¨"

    é€€å‡ºçš„æ“ä½œå¹¶ä¸åªç”¨äºå½“å‰è¿›ç¨‹ï¼Œä¹Ÿå¯ä»¥ä½œç”¨äºå…¶ä»–è¿›ç¨‹ï¼Œå› æ­¤å¯ä»¥é€šè¿‡å¦‚ä¸‹æ–¹å¼å°†å®ƒä»¬ç»Ÿä¸€ï¼š

    ```rust
    pub fn kill_self(&self, ret: isize) {
        self.kill(processor::current_pid(), ret);
    }

    pub fn kill(&self, pid: ProcessId, ret: isize) {
       // FIXME: get process by pid
       // FIXME: kill process and set return code
    }
    ```

    è¿™åªæ˜¯ä¸€ç§å¯èƒ½çš„å®ç°æ–¹å¼ï¼Œä½ å¯ä»¥æ ¹æ®è‡ªå·±çš„éœ€æ±‚è¿›è¡Œè°ƒæ•´ã€‚

è¿›ç¨‹é€€å‡ºé‡Šæ”¾èµ„æºçš„è¿‡ç¨‹åŸºæœ¬æœ‰å¦‚ä¸‹å‡ æ­¥ï¼š

1. é‡Šæ”¾è¿›ç¨‹çš„é¡µè¡¨ï¼Œé‡Šæ”¾é¡µè¡¨å ç”¨çš„é¡µé¢ã€‚

    > è¿™éƒ¨åˆ†å°†åœ¨åç»­å®éªŒä¸­å®ç°ã€‚æ­¤å¤„ä¸éœ€è¦å…³å¿ƒï¼Œä½†æ˜¯å»ºè®®å®Œæˆ **åŠ åˆ†é¡¹ 2** çš„å†…å®¹

2. åˆ é™¤è¿›ç¨‹çš„æ•°æ®ï¼ˆ`ProcessData`ï¼‰ï¼Œå¯ä»¥ä½¿ç”¨ `take` æ–¹æ³•ã€‚

3. è®¾ç½®è¿›ç¨‹çš„è¿”å›å€¼ï¼Œå¹¶è®¾ç½®çŠ¶æ€ä¸º `Dead`ã€‚

!!! success "é˜¶æ®µæ€§æˆæœ"

    ç»ˆäºï¼åœ¨å®ç°è¿›ç¨‹çš„é€€å‡ºä¹‹åï¼Œç”¨æˆ·ç¨‹åºå¯ä»¥ç”Ÿæˆå¹¶æ­£ç¡®é€€å‡ºäº†ï¼

    å°è¯•ä¿®æ”¹ç”¨æˆ·æ€åº“ä¸­çš„ `entry!` å’Œ `panic` å‡½æ•°ï¼Œåœ¨ç”¨æˆ·ç¨‹åºä¸­è°ƒç”¨ `exit` ç³»ç»Ÿè°ƒç”¨ï¼Œå¹¶ä¼ é€’ä¸€ä¸ªè¿”å›å€¼ï¼Œä»¥éªŒè¯ç”¨æˆ·ç¨‹åºçš„é€€å‡ºåŠŸèƒ½ã€‚

    å€¼æ­¤ä¸ºæ­¢ï¼Œä½ åº”å½“å¯ä»¥ç”Ÿæˆç”¨æˆ·ç¨‹åºã€è¾“å‡º `Hello, world!!!`ï¼Œå¹¶æ­£ç¡®é€€å‡ºã€‚

### è¿›ç¨‹çš„åˆ›å»ºä¸ç­‰å¾…

æ“ä½œç³»ç»Ÿçš„å†…æ ¸å…¥å£ç‚¹å°†èƒ½å¤Ÿç®€å•å®ç°å¦‚ä¸‹åŠŸèƒ½ï¼š

1. åˆå§‹åŒ–å†…æ ¸
2. ç”Ÿæˆ `init` è¿›ç¨‹ï¼Œå¹¶ç­‰å¾…å®ƒé€€å‡º
3. å…³æœº

è€Œå…·ä½“çš„è¿›ç¨‹æ“ä½œã€ç›®å½•æ“ä½œç­‰åŠŸèƒ½ï¼Œå°†ä¼šç§»æ­¥åˆ°ç”¨æˆ·æ€ç¨‹åºè¿›è¡Œå®ç°ã€‚ä¸ºäº†ç»™äºˆç”¨æˆ·æ€ç¨‹åºæ“ä½œè¿›ç¨‹ã€ç­‰å¾…è¿›ç¨‹é€€å‡ºçš„èƒ½åŠ›ï¼Œè¿™é‡Œè¿˜ç¼ºå°‘æœ€åä¸¤ä¸ªç³»ç»Ÿè°ƒç”¨éœ€è¦å®ç°ï¼š`spawn` å’Œ `waitpid`ã€‚

å¯¹è¿™ä¸¤ä¸ªç³»ç»Ÿè°ƒç”¨æœ‰å¦‚ä¸‹çº¦å®šï¼š

```rust
// path: &str (arg0 as *const u8, arg1 as len) -> pid: u16
Syscall::Spawn => { /* ... */ },
// pid: arg0 as u16 -> status: isize
Syscall::WaitPid => { /* ... */},
```

ç›¸å…³å¿…è¦å‡½æ•°å’Œå‚è€ƒä»£ç åœ¨å‰æ–‡ä¸­å‡æœ‰æ¶‰åŠï¼Œä½ å¯ä»¥å‚è€ƒå‰æ–‡çš„å†…å®¹è¿›è¡Œç³»ç»Ÿè°ƒç”¨çš„å®ç°ã€‚

> ä½ å¯ä»¥è‡ªç”±å®šä¹‰ä½ çš„å†…æ ¸ä¸ç”¨æˆ·æ€çš„äº¤äº’æ–¹å¼äº†ï¼

!!! note "å…³äº `WaitPid` çš„é—®é¢˜"

    ä½ å¯èƒ½ä¼šå‘ç°ï¼Œ`WaitPid` éœ€è¦è¿”å›ç‰¹æ®ŠçŠ¶æ€ï¼Œä»¥åŒºåˆ†è¿›ç¨‹æ­£åœ¨è¿è¡Œè¿˜æ˜¯å·²ç»é€€å‡ºã€‚

    ä¸è¿‡éå¸¸ç³Ÿç³•ï¼Œå½“å‰è¿›ç¨‹çš„è¿”å›å€¼ä¹Ÿæ˜¯ä¸€ä¸ª `isize` ç±»å‹çš„å€¼ï¼Œè¿™æ„å‘³ç€å¦‚æœæŒ‰ç…§ç°åœ¨çš„è®¾è®¡ï¼ŒåŠ¿å¿…å­˜åœ¨ä¸€äº›è¿”å›å€¼å’Œâ€œæ­£åœ¨è¿è¡Œâ€çš„çŠ¶æ€å†²çªã€‚

    ä¸è¿‡åœ¨ç®€å•çš„å®éªŒä¸­ï¼Œè¿™å¹¶ä¸ä¼šé€ æˆå¤ªå¤§çš„é—®é¢˜ï¼Œè€Œæ­¤é—®é¢˜çš„è§£å†³æ–¹æ¡ˆä¹Ÿç•™ä½œåŠ åˆ†é¡¹ä¾›å¤§å®¶ç ”ç©¶ã€‚

    **å¦è¯·æ³¨æ„ï¼Œ`WaitPid` è™½ç„¶åä¸º `wait` ä½†æ˜¯å¹¶ä¸ä¼šè¿›è¡Œé˜»å¡ï¼Œåº”å½“ç«‹åˆ»è¿”å›è¿›ç¨‹çš„å½“å‰çŠ¶æ€ã€‚**

## è¿è¡Œ Shell

è‡³æ­¤ï¼Œä½ å¯ä»¥ç¼–å†™è‡ªå·±çš„ Shell äº†ï¼ä½œä¸ºç”¨æˆ·ä¸æ“ä½œç³»ç»Ÿçš„äº¤äº’æ–¹å¼ï¼Œå®ƒéœ€è¦å®ç°ä¸€äº›å¿…é¡»åŠŸèƒ½ï¼š

- åˆ—å‡ºå½“å‰ç³»ç»Ÿä¸­çš„æ‰€æœ‰ç”¨æˆ·ç¨‹åº
- åˆ—å‡ºå½“å‰æ­£åœ¨è¿è¡Œçš„å…¨éƒ¨è¿›ç¨‹
- è¿è¡Œä¸€ä¸ªç”¨æˆ·ç¨‹åº

åŒæ—¶ï¼Œå®ƒä¹Ÿå¯ä»¥å®ç°ä¸€äº›è¾…åŠ©çš„èƒ½åŠ›ï¼š

- åˆ—å‡ºå¸®åŠ©ä¿¡æ¯
- æ¸…ç©ºå±å¹•
- ...

ä¸ºäº†å®ç°ä¸€äº›ä¿¡æ¯çš„æŸ¥çœ‹ï¼Œä½ ä¹Ÿéœ€è¦å®ç°å¦‚ä¸‹ä¸¤ä¸ªç³»ç»Ÿè°ƒç”¨ï¼š

```rust
// None
Syscall::Stat => { /* ... */ },
// None
Syscall::ListApp => { /* ... */},
```

!!! tip "å®éªŒä»»åŠ¡"

    å°è¯•ç»“åˆ lab 0 çš„å†…å®¹ï¼Œå®ç°ä¸€ä¸ªä½ è‡ªå·±çš„ Shellï¼

    å®ƒåº”å½“èƒ½å¤Ÿç”Ÿæˆä¸€ä¸ªç”¨æˆ·ç¨‹åºï¼Œç­‰å¾…å®ƒé€€å‡ºï¼Œå¹¶è¾“å‡ºå®ƒçš„è¿”å›å€¼ã€‚å®ç°è¾ƒä¸ºçµæ´»ï¼Œä½ å¯ä»¥è‡ªè¡Œè°ƒæ•´ç”¨æˆ·æ€åº“å’Œç”¨æˆ·ç¨‹åºï¼Œä»¥ä½ å–œæ¬¢çš„æ–¹å¼æ„å»ºæ“ä½œç³»ç»Ÿçš„ç”¨æˆ·æ€ã€‚

    é™¤æ­¤ä¹‹å¤–ï¼Œè¯·å®ç° `help` å‘½ä»¤ï¼Œå¹¶åœ¨å…¶ä¸­è¾“å‡ºå¸®åŠ©ä¿¡æ¯ï¼Œå¹¶é™„åŠ ä½ çš„å­¦å·ã€‚

### æµ‹è¯•ç¨‹åº

ä½œä¸ºä¹‹å‰æ‰€æœ‰ç¨‹åºåŠŸèƒ½çš„æµ‹è¯•å’Œæ£€éªŒï¼Œä½ éœ€è¦åœ¨ç”¨æˆ·æ€ä¸‹æ­£ç¡®è¿è¡Œå¦‚ä¸‹ç¨‹åºï¼š

```rust
const MOD: u64 = 1000000007;

fn factorial(n: u64) -> u64 {
    if n == 0 {
        1
    } else {
        n * factorial(n - 1) % MOD
    }
}

fn main() -> usize {
    print!("Input n: ");

    let input = lib::stdin().read_line();

    // prase input as u64
    let n = input.parse::<u64>().unwrap();

    if n > 1000000 {
        println!("n must be less than 1000000");
        return 1;
    }

    // calculate factorial
    let result = factorial(n);

    // print system status
    sys_stat();

    // print result
    println!("The factorial of {} under modulo {} is {}.", n, MOD, result);

    0
}

entry!(main);
```

ä½ å¯ä»¥è¿›è¡Œä¸€äº›äº¤äº’æµ‹è¯•ï¼Œä¾‹å¦‚è¾“å…¥ `100` æˆ–æ›´å¤§çš„æ•°æ®ï¼ˆä¼šäº§ç”Ÿæ›´å¤§çš„æ ˆå ç”¨ï¼ï¼‰å¹¶æŸ¥çœ‹è¾“å‡ºç»“æœã€‚åœ¨æœ€å¤§è§„æ¨¡ï¼ˆè¾“å…¥æ•°æ®ä¸º `999999` æ—¶ï¼‰ï¼Œé¢„æœŸè¾“å‡ºä¸ºï¼š

```
The factorial of 999999 under modulo 1000000007 is 128233642.
```

ä½ å¯ä»¥ä½¿ç”¨æ­¤æµ‹ä¾‹æ¥è¿›è¡Œå¯¹ç…§å‚è€ƒã€‚æ­¤ç”¨æˆ·ç¨‹åºçº¦å ç”¨ 3929 ä¸ªé¡µé¢ï¼Œæ€»è®¡å†…å­˜å ç”¨çº¦ 15.3MiBã€‚

## æ€è€ƒé¢˜

1. æ˜¯å¦å¯ä»¥åœ¨å†…æ ¸çº¿ç¨‹ä¸­ä½¿ç”¨ç³»ç»Ÿè°ƒç”¨ï¼Ÿå¹¶å€Ÿæ­¤æ¥å®ç°åŒæ ·çš„è¿›ç¨‹é€€å‡ºèƒ½åŠ›ï¼Ÿåˆ†æå¹¶å°è¯•å›ç­”ã€‚

2. ä¸ºä»€ä¹ˆéœ€è¦å…‹éš†å†…æ ¸é¡µè¡¨ï¼Ÿåœ¨ç³»ç»Ÿè°ƒç”¨çš„å†…æ ¸æ€ä¸‹ä½¿ç”¨çš„æ˜¯å“ªä¸€å¼ é¡µè¡¨ï¼Ÿç”¨æˆ·æ€ç¨‹åºå°è¯•è®¿é—®å†…æ ¸ç©ºé—´ä¼šè¢«æ­£ç¡®æ‹¦æˆªå—ï¼Ÿå°è¯•éªŒè¯ä½ çš„å®ç°æ˜¯å¦æ­£ç¡®ã€‚

## åŠ åˆ†é¡¹

1. ğŸ˜‹ å°è¯•åœ¨ `ProcessData` ä¸­è®°å½•ä»£ç æ®µçš„å ç”¨æƒ…å†µï¼Œå¹¶ç»Ÿè®¡å½“å‰è¿›ç¨‹æ‰€å ç”¨çš„é¡µé¢æ•°é‡ï¼Œå¹¶åœ¨æ‰“å°è¿›ç¨‹ä¿¡æ¯æ—¶ï¼Œå°†è¿›ç¨‹çš„å†…å­˜å ç”¨æ‰“å°å‡ºæ¥ã€‚

2. ğŸ˜‹ å°è¯•åœ¨ `kernel/src/memory/frames.rs` ä¸­å®ç°å¸§åˆ†é…å™¨çš„å›æ”¶åŠŸèƒ½ `FrameDeallocator`ï¼Œä½œä¸ºä¸€ä¸ªæœ€å°åŒ–çš„å®ç°ï¼Œä½ å¯ä»¥åœ¨ `Allocator` ä½¿ç”¨ä¸€ä¸ª `Vec` å­˜å‚¨è¢«é‡Šæ”¾çš„é¡µé¢ï¼Œå¹¶åœ¨åˆ†é…æ—¶ä»ä¸­å–å‡ºã€‚

3. ğŸ¤” åŸºäºå¸§å›æ”¶å™¨çš„å®ç°ï¼Œåœ¨ `elf` ä¸­å®ç° `unmap_range` å‡½æ•°ï¼Œä»é¡µè¡¨ä¸­å–æ¶ˆæ˜ å°„ä¸€æ®µè¿ç»­çš„é¡µé¢ï¼Œå¹¶ä½¿ç”¨å¸§å›æ”¶å™¨è¿›è¡Œå›æ”¶ã€‚åˆ©ç”¨å®ƒå®ç°è¿›ç¨‹æ ˆçš„å›æ”¶ï¼ˆåˆ©ç”¨ `ProcessData` ä¸­å­˜å‚¨çš„é¡µé¢ä¿¡æ¯ï¼‰ã€‚**é¡µè¡¨çš„å›æ”¶å°†ä¼šåœ¨åç»­å®ç°ç”¨å®ç°ï¼Œæš‚æ—¶ä¸éœ€è¦å¤„ç†**

4. ğŸ¤” æ”¹è¿›æˆ–é‡æ–°è®¾è®¡è¿›ç¨‹è¿”å›å€¼çš„ç›¸å…³å†…å®¹ï¼Œç»™äºˆ `WaitPid` æ›´å¥½çš„å…¼å®¹æ€§ï¼Œæè¿°ä½ çš„è®¾è®¡å’Œå®ç°ã€‚

5. ğŸ¤” å°è¯•åˆ©ç”¨ `UefiRuntime` å’Œ `chrono` crateï¼Œè·å–å½“å‰æ—¶é—´ï¼Œå¹¶å°†å…¶æš´éœ²ç»™ç”¨æˆ·æ€ï¼Œä»¥å®ç° `sleep` å‡½æ•°ã€‚

    `UefiRuntime` çš„å®ç°ï¼š

    ```rust
    pub struct UefiRuntime {
        runtime_service: &'static RuntimeServices,
    }

    impl UefiRuntime {
        pub unsafe fn new(boot_info: &'static BootInfo) -> Self {
            Self {
                runtime_service: boot_info.system_table.runtime_services(),
            }
        }

        pub fn get_time(&self) -> Time {
            self.runtime_service.get_time().unwrap()
        }
    }
    ```

    ä¸€ä¸ªå¯èƒ½çš„ `sleep` å‡½æ•°å®ç°ï¼š

    ```rust
    pub fn sleep(millisecs: i64) {
        let start = sys_time();
        let dur = Duration::milliseconds(millisecs);
        let mut current = start;
        while current - start < dur {
            current = sys_time();
        }
    }
    ```

    åœ¨å®ç°åï¼Œå†™ä¸€ä¸ªæˆ–æ›´æ”¹ç°æœ‰ç”¨æˆ·ç¨‹åºï¼ŒéªŒè¯ä½ çš„å®ç°æ˜¯å¦æ­£ç¡®ï¼Œå°è¯•è¾“å‡ºå½“å‰æ—¶é—´å¹¶ç­‰å¾…ä¸€æ®µæ—¶é—´ã€‚

    > å½“å‰å®ç°æ˜¯çº¯ç”¨æˆ·æ€ã€é‡‡ç”¨è½®è¯¢çš„ï¼Œè¿™ç§å®ç°æ˜¯å¾ˆä½æ•ˆçš„ã€‚åœ¨ç°ä»£æ“ä½œç³»ç»Ÿä¸­ï¼Œè¿›ç¨‹ä¼šè¢«æŒ‚èµ·ï¼Œå¹¶ç­‰å¾…å¯¹åº”äº‹ä»¶è§¦å‘åé‡æ–°è¢«è°ƒåº¦ã€‚

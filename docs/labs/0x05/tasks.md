# å®éªŒäº”ï¼šfork çš„å®ç°ã€å¹¶å‘ä¸é”æœºåˆ¶

!!! danger "åœ¨æ‰§è¡Œæ¯ä¸€æ¡å‘½ä»¤å‰ï¼Œè¯·ä½ å¯¹å°†è¦è¿›è¡Œçš„æ“ä½œè¿›è¡Œæ€è€ƒ"

    **ä¸ºäº†ä½ çš„æ•°æ®å®‰å…¨å’Œä¸å¿…è¦çš„éº»çƒ¦ï¼Œè¯·è°¨æ…ä½¿ç”¨ `sudo`ï¼Œå¹¶ç¡®ä¿ä½ äº†è§£æ¯ä¸€æ¡æŒ‡ä»¤çš„å«ä¹‰ã€‚**

    **1. å®éªŒæ–‡æ¡£ç»™å‡ºçš„å‘½ä»¤ä¸éœ€è¦å…¨éƒ¨æ‰§è¡Œ**

    **2. ä¸æ˜¯æ‰€æœ‰çš„å‘½ä»¤éƒ½å¯ä»¥æ— æ¡ä»¶æ‰§è¡Œ**

    **3. ä¸è¦ç›´æ¥å¤åˆ¶ç²˜è´´å‘½ä»¤æ‰§è¡Œ**

## fork çš„å®ç°

åœ¨æ“ä½œç³»ç»Ÿè®¾è®¡ä¸­ï¼Œè¿›ç¨‹çš„æ§åˆ¶é™¤äº†åˆ›å»ºã€ç»ˆæ­¢ç­‰åŸºæœ¬æ“ä½œä¹‹å¤–ï¼Œè¿˜åŒ…æ‹¬äº†è¿›ç¨‹çš„**å¤åˆ¶**ã€‚

è¿™ç§å¤åˆ¶çš„æ“ä½œå¯ä»¥ç”¨äºåˆ›å»º**å­è¿›ç¨‹**ï¼Œè¢«ç§°ä¸º `fork`ï¼Œå®ƒå¯ä»¥ä½¿å¾—ç”¨æˆ·è¿›ç¨‹å…·æœ‰æ§åˆ¶å¤šä¸ªè¿›ç¨‹çš„èƒ½åŠ›ï¼Œä»è€Œå®ç°å¹¶å‘æ‰§è¡Œã€‚

YSOS çš„ `fork` ç³»ç»Ÿè°ƒç”¨è®¾è®¡å¦‚ä¸‹æè¿°ï¼š

!!! note "å‡ºäºå®éªŒè®¾è®¡è€ƒé‡ï¼š<br/>æœ¬å®ç°ä¸ Linux æˆ– [POSIX](https://pubs.opengroup.org/onlinepubs/9699919799/) ä¸­æ‰€å®šä¹‰çš„ `fork` æœ‰æ‰€ä¸åŒï¼Œä¹Ÿç»“åˆäº† Linux ä¸­ `vfork` çš„è¡Œä¸ºã€‚"

-   `fork` ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„è¿›ç¨‹ï¼Œæ–°è¿›ç¨‹ç§°ä¸ºå­è¿›ç¨‹ï¼ŒåŸè¿›ç¨‹ç§°ä¸ºçˆ¶è¿›ç¨‹ã€‚
-   **å­è¿›ç¨‹åœ¨ç³»ç»Ÿè°ƒç”¨åå°†å¾—åˆ° `0` çš„è¿”å›å€¼ï¼Œè€Œçˆ¶è¿›ç¨‹å°†å¾—åˆ°å­è¿›ç¨‹çš„ PIDã€‚** å¦‚æœåˆ›å»ºå¤±è´¥ï¼Œçˆ¶è¿›ç¨‹å°†å¾—åˆ° `-1` çš„è¿”å›å€¼ã€‚
-   `fork` **ä¸å¤åˆ¶**çˆ¶è¿›ç¨‹çš„å†…å­˜ç©ºé—´ï¼Œ**ä¸å®ç°** Cow (Copy on Write) æœºåˆ¶ï¼Œå³çˆ¶å­è¿›ç¨‹å°†æŒæœ‰ä¸€å®šçš„å…±äº«å†…å­˜ï¼šä»£ç æ®µã€æ•°æ®æ®µã€å †ã€bss æ®µç­‰ã€‚
-   `fork` å­è¿›ç¨‹ä¸çˆ¶è¿›ç¨‹å…±äº«å†…å­˜ç©ºé—´ï¼ˆé¡µè¡¨ï¼‰ï¼Œä½†**å­è¿›ç¨‹æ‹¥æœ‰è‡ªå·±ç‹¬ç«‹çš„å¯„å­˜å™¨å’Œæ ˆç©ºé—´ï¼Œå³åœ¨ä¸€ä¸ªä¸åŒçš„æ ˆçš„åœ°å€ç»§æ‰¿åŸæ¥çš„æ•°æ®ã€‚**
-   **ç”±äºä¸Šè¿°å†…å­˜åˆ†é…æœºåˆ¶çš„é™åˆ¶ï¼Œ`fork` ç³»ç»Ÿè°ƒç”¨å¿…é¡»åœ¨ä»»ä½• Rust å†…å­˜åˆ†é…ï¼ˆå †å†…å­˜åˆ†é…ï¼‰ä¹‹å‰è¿›è¡Œã€‚**

ä¸ºäº†å®ç°çˆ¶å­è¿›ç¨‹çš„èµ„æºå…±äº«ï¼Œåœ¨å…ˆå‰çš„å®éªŒä¸­ï¼Œå·²ç»åšäº†ä¸€äº›å‡†å¤‡å·¥ä½œï¼š

æ¯”å¦‚ `pkg/kernel/src/proc/paging.rs` ä¸­ï¼Œ`PageTableContext` ä¸­çš„ `Cr3RegValue` è¢« `Arc` ä¿æŠ¤äº†èµ·æ¥ï¼›åœ¨ `pkg/kernel/src/proc/data.rs` ä¸­ï¼Œä¹Ÿå­˜åœ¨ `Arc` åŒ…è£…çš„å…±äº«æ•°æ®çš„å†…å®¹ã€‚

??? note "å¿˜äº† `Arc` æ˜¯ä»€ä¹ˆï¼Ÿ"

    `Arc` æ˜¯ `alloc::sync` ä¸­çš„ä¸€ä¸ªåŸå­å¼•ç”¨è®¡æ•°æ™ºèƒ½æŒ‡é’ˆï¼Œå®ƒå…è®¸å¤šä¸ªçº¿ç¨‹åŒæ—¶æ‹¥æœ‰å¯¹åŒä¸€æ•°æ®çš„æ‰€æœ‰æƒï¼Œä¸”ä¸ä¼šé€ æˆæ•°æ®ç«äº‰ã€‚

    `Arc` çš„ `clone()` æ–¹æ³•ä¼šå¢åŠ å¼•ç”¨è®¡æ•°ï¼Œ`drop()` æ–¹æ³•ä¼šå‡å°‘å¼•ç”¨è®¡æ•°ï¼Œå½“å¼•ç”¨è®¡æ•°ä¸º 0 æ—¶ï¼Œæ•°æ®ä¼šè¢«é‡Šæ”¾ã€‚`Arc` æœ¬èº«æ˜¯**ä¸å¯å˜çš„**ï¼Œä½†å¯ä»¥é€šè¿‡ `RwLock` è·å–å†…éƒ¨å¯å˜æ€§ï¼Œè¿›è€Œå®‰å…¨çš„ä¿®æ”¹ä¸€ä¸ªè¢«å¤šä¸ªçº¿ç¨‹æ‰€æŒæœ‰çš„æ•°æ®ã€‚

å¯¹äº Windows ç­‰å°†è¿›ç¨‹æŠ½è±¡ä¸ºèµ„æºå®¹å™¨çš„æ“ä½œç³»ç»Ÿï¼Œè¿™äº›éœ€è¦å…±äº«çš„èµ„æºä¹Ÿå°±ä¼šè¢«æŠ½è±¡ä¸º**è¿›ç¨‹å¯¹è±¡**ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå®éªŒæ‰€è®¾è®¡çš„è¡Œä¸ºåˆæ›´ç±»ä¼¼äº â€œæ–°å»ºä¸€ä¸ªæ‰§è¡Œçº¿ç¨‹â€ çš„æ“ä½œã€‚

### ç³»ç»Ÿè°ƒç”¨

æœ‰äº†ä¸Šä¸€æ¬¡å®éªŒçš„ç»éªŒï¼Œç³»ç»Ÿè°ƒç”¨çš„æ–°å¢ã€å¤„ç†å‡å·²ç»æœ‰äº†ä¸€å®šçš„ç»éªŒï¼Œæ­¤å¤„ä¸è¿‡å¤šèµ˜è¿°ã€‚å¯¹ `fork` ç³»ç»Ÿè°ƒç”¨æœ‰å¦‚ä¸‹çº¦å®šï¼Œåˆ«å¿˜äº†åœ¨ `syscall_def` ä¸­å®šä¹‰ä½ çš„ç³»ç»Ÿè°ƒç”¨å·ï¼š

```rust
// None -> pid: u16 or 0 or -1
Syscall::Fork => { /* ... */},
```

!!! tip "å¦‚æœä½ å’Œç¬”è€…ä¸€æ ·æœ‰å¼ºè¿«ç—‡ï¼ŒLinux ç›¸å…³åŠŸèƒ½çš„ç³»ç»Ÿè°ƒç”¨å·æ˜¯ `58`"

### è¿›ç¨‹ç®¡ç†

!!! warning "å…³äºå…·ä½“çš„å®ç°"

    å®éªŒè‡³æ­¤ï¼Œä½ ä¹Ÿåº”å½“ç§¯ç´¯äº†ä¸€äº›è‡ªå·±çš„é¡¹ç›®ç®¡ç†ç»éªŒï¼Œå¯¹äºä¸Šè¿°çš„ `FIXME`ï¼Œä½ åº”å½“æœ‰ä¸€äº›è‡ªå·±çš„æƒ³æ³•ï¼Œç”¨åˆé€‚çš„æ–¹å¼è¿›è¡Œå®ç°ã€‚

    åç»­çš„å®Œå–„å°†ä¼šç»™å‡ºä¸€äº›æç¤ºã€å»ºè®®å’Œæ³¨æ„äº‹é¡¹ï¼Œç›¸å…³ä»£ç ç»“æ„å¹¶ä¸éœ€è¦**å®Œå…¨æŒ‰ç…§æ–‡æ¡£è¿›è¡Œ**ã€‚

    **è¯·æ³¨æ„ï¼šæ¯ä¸ª `FIXME` å¹¶ä¸ä»£è¡¨æ­¤åŠŸèƒ½å¿…é¡»åœ¨å¯¹åº”çš„ä½ç½®å®ç°ï¼Œä½ ä¹Ÿåº”å½“è‡ªç”±ç®¡ç†ç›¸å…³å‡½æ•°çš„è¿”å›å€¼ã€å‚æ•°ç­‰ã€‚**

åœ¨å¤„ç†å¥½ç”¨æˆ·æ€åº“å’Œç³»ç»Ÿè°ƒç”¨çš„å¯¹æ¥åï¼Œå‚è€ƒå¦‚ä¸‹ä»£ç ï¼Œå®Œå–„ä½ çš„ `fork`:

!!! note "å¾€ä¸‹ç¿»ç¿»ï¼Œè¯´æ˜æ›´å¤šå“¦ï¼ˆä¸ºä»€ä¹ˆæ€»æœ‰äººä¸çœ‹å®Œæ–‡æ¡£å°±å¼€å§‹å†™ä»£ç ï¼ï¼‰"

```rust
pub fn fork(context: &mut ProcessContext) {
    x86_64::instructions::interrupts::without_interrupts(|| {
        let manager = get_process_manager();
        // FIXME: save_current as parent
        // FIXME: fork to get child
        // FIXME: push to child & parent to ready queue
        // FIXME: switch to next process
    })
}
```

```rust
impl ProcessManager {
    pub fn fork(&self) {
        // FIXME: get current process
        // FIXME: fork to get child
        // FIXME: add child to process list

        // FOR DBG: maybe print the process ready queue?
    }
}
```

```rust
impl Process {
    pub fn fork(self: &Arc<Self>) -> Arc<Self> {
        // FIXME: lock inner as write
        // FIXME: inner fork with parent weak ref

        // FOR DBG: maybe print the child process info
        //          e.g. parent, name, pid, etc.

        // FIXME: make the arc of child
        // FIXME: add child to current process's children list
        // FIXME: set fork ret value for parent with `context.set_rax`
        // FIXME: mark the child as ready & return it
    }
}
```

```rust
pub struct ProcessInner {
    // ...
    parent: Option<Weak<Process>>,
    children: Vec<Arc<Process>>,
    // ...
}

impl ProcessInner {
    pub fn fork(&mut self, parent: Weak<Process>) -> ProcessInner {
        // FIXME: fork the process virtual memory struct
        // FIXME: calculate the real stack offset
        // FIXME: update `rsp` in interrupt stack frame
        // FIXME: set the return value 0 for child with `context.set_rax`

        // FIXME: clone the process data struct

        // FIXME: construct the child process inner

        // NOTE: return inner because there's no pid record in inner
    }
}
```

```rust
impl ProcessVm {
    pub fn fork(&self, stack_offset_count: u64) -> Self {
        // clone the page table context (see instructions)
        let owned_page_table = self.page_table.fork();

        let mapper = &mut owned_page_table.mapper();
        let alloc = &mut *get_frame_alloc_for_sure();

        Self {
            page_table: owned_page_table,
            stack: self.stack.fork(mapper, alloc, stack_offset_count),
        }
    }
}

impl Stack {
    pub fn fork(
        &self,
        mapper: MapperRef,
        alloc: FrameAllocatorRef,
        stack_offset_count: u64,
    ) -> Self {
        // FIXME: alloc & map new stack for child (see instructions)

        // FIXME: copy the *entire stack* from parent to child

        // FIXME: return the new stack
        Self {
            range: /* new stack range */,
            usage: /* new stack usage */
        }
    }
}
```

å…³äºå…·ä½“çš„ä»£ç å®ç°ï¼Œå‚è€ƒå¦‚ä¸‹çš„æç¤ºå’Œè¯´æ˜ï¼š

1.  å°†åŠŸèƒ½çš„å…·ä½“å®ç°å§”æ‰˜è‡³ä¸‹ä¸€çº§è¿›è¡Œï¼Œä¿æŒä»£ç è¯­ä¹‰çš„ç®€æ´ã€‚

    -   ç³»ç»Ÿè°ƒç”¨é™æ€å‡½æ•°ï¼Œå¹¶å°†å…¶å§”æ‰˜ç»™ `ProcessManager::fork`ã€‚
    -   `ProcessManager::fork` å°†å…·ä½“å®ç°å§”æ‰˜ç»™å½“å‰è¿›ç¨‹çš„ `Process::fork`ã€‚
    -   `Process::fork` å°†å…·ä½“å®ç°å§”æ‰˜ç»™ `ProcessInner::fork`ã€‚

    æ¯ä¸€å±‚ä»£ç åªå…³å¿ƒè‡ªå·±å±‚çº§çš„é€»è¾‘å’Œæ•°æ®ï¼Œä¸å…³å¿ƒæŒæœ‰è‡ªèº«çš„é”æˆ–å…¶ä»–å¤–éƒ¨æ•°æ®çš„çŠ¶æ€ï¼Œè¿›è€Œæé«˜ä»£ç å¯ç»´æŠ¤æ€§ã€‚

2.  ä½¿ç”¨å…ˆå‰å®ç°çš„ `save_current` å’Œ `switch_next` ç­‰å‡½æ•°ï¼Œæé«˜ä»£ç å¤ç”¨æ€§ã€‚

    å¦‚æœä½¿ç”¨æ—¶é‡åˆ°äº†é—®é¢˜ï¼Œå¾ˆå¯èƒ½æ˜¯ä½ çš„ä»£ç è¿‡äºç›¸äº’è€¦åˆï¼Œå°è¯•å°†é€»è¾‘è¿›è¡Œåˆ†ç¦»ï¼Œä¿è¯å‡½æ•°åŠŸèƒ½çš„å•ä¸€æ€§ã€‚

3.  åˆ†åˆ«ä¸ºçˆ¶å­è¿›ç¨‹è®¾ç½®è¿”å›å€¼ã€‚

    è¿›ç¨‹è°ƒç”¨ç³»ç»Ÿè°ƒç”¨åï¼Œä¼šæ ¹æ®**æ¢å¤çš„å¯„å­˜å™¨çš„å€¼**è·å–ç³»ç»Ÿè°ƒç”¨çš„è¿”å›å€¼ã€‚

    å¯¹äº `fork` ç³»ç»Ÿè°ƒç”¨ï¼Œéœ€è¦ä¸ºçˆ¶è¿›ç¨‹å’Œå­è¿›ç¨‹è®¾ç½®ä¸åŒçš„è¿”å›å€¼ï¼Œè¿™æ„å‘³ç€ä¸ºä»–ä»¬ä¸åŒçš„ `context` è®¾ç½® `rax` å¯„å­˜å™¨ã€‚

    è®¾ç½®å­è¿›ç¨‹çš„ `context` æ—¶ï¼Œå…ˆæ ¹æ®çˆ¶è¿›ç¨‹è¿›è¡Œå¤åˆ¶ï¼Œå¹¶åœ¨å¤åˆ¶åä¿®æ”¹ `rax` ä¸º 0ã€‚

4.  ä½¿ç”¨ `Arc::downgrade` è·å– `Weak` å¼•ç”¨ï¼Œä»è€Œé¿å…å¾ªç¯å¼•ç”¨ã€‚

    çˆ¶è¿›ç¨‹æŒæœ‰å­è¿›ç¨‹çš„å¼ºå¼•ç”¨ï¼Œå­è¿›ç¨‹æŒæœ‰çˆ¶è¿›ç¨‹çš„å¼±å¼•ç”¨ï¼Œè¿™æ ·å¯ä»¥é¿å…å¾ªç¯å¼•ç”¨å¯¼è‡´çš„å†…å­˜æ³„æ¼ã€‚

5.  ä¸ºäº†å¤åˆ¶æ ˆç©ºé—´ï¼Œä½ å¯ä»¥ä½¿ç”¨ `core::intrinsics::copy_nonoverlapping` å‡½æ•°ã€‚

    è¿™ä¸ªå‡½æ•°ä¼šä½¿ç”¨åº•å±‚ LLVM æ‰€æä¾›çš„å†…å­˜å¤åˆ¶ç›¸å…³æŒ‡ä»¤ï¼Œå…·æœ‰è¾ƒé«˜çš„æ€§èƒ½ã€‚éœ€è¦è°ƒç”¨ä¾§ä¿è¯æºå’Œç›®æ ‡çš„å†…å­˜ç©ºé—´ä¸ä¼šé‡å ã€‚å¯ä»¥å°è£…ä¸ºå¦‚ä¸‹å‡½æ•°è¿›è¡Œä½¿ç”¨ï¼š

    ```rust
    /// Clone a range of memory
    ///
    /// - `src_addr`: the address of the source memory
    /// - `dest_addr`: the address of the target memory
    /// - `size`: the count of pages to be cloned
    fn clone_range(&self, cur_addr: u64, dest_addr: u64, size: u64) {
        trace!("Clone range: {:#x} -> {:#x}", cur_addr, dest_addr);
        unsafe {
            copy_nonoverlapping::<u64>(
                cur_addr as *mut u64,
                dest_addr as *mut u64,
                (size * Size4KiB::SIZE / 8) as usize,
            );
        }
    }
    ```

6.  è®°å½•çˆ¶å­è¿›ç¨‹å…±ç”¨çš„é¡µè¡¨ã€‚

    å¯ä»¥ä½¿ç”¨ `Arc` æ¥æä¾›å¼•ç”¨è®¡æ•°ï¼Œæ¥ç¡®ä¿è¿›ç¨‹é€ä¸ªé€€å‡ºæ—¶ï¼Œåªæœ‰æœ€åä¸€ä¸ªé€€å‡ºçš„è¿›ç¨‹ä¼šè¿›è¡Œé¡µè¡¨å†…å®¹çš„é‡Šæ”¾ã€‚ä¸ºæ­¤ï¼Œä½ éœ€è¦è¡¥å……ä¸€äº›ç›¸å…³çš„å‡½æ•°è°ƒç”¨ï¼š

    ```rust
    impl PageTableContext {
        // ...
        pub fn using_count(&self) -> usize {
            Arc::strong_count(&self.reg)
        }

        pub fn fork(&self) -> Self {
            // forked process shares the page table
            Self {
                reg: self.reg.clone(),
            }
        }
        // ...
    }
    ```

    ä¹Ÿå¯ä»¥è¡¥å……ä¸€äº›ç›¸å…³çš„è°ƒè¯•ä¿¡æ¯ï¼š

    ```rust
    impl Debug for PageTableContext {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            // ...
                .field("refs", &self.using_count())
            // ...
        }
    }
    ```

7.  ä¸ºå­è¿›ç¨‹åˆ†é…åˆé€‚çš„æ ˆç©ºé—´ã€‚

    é€šè¿‡å­è¿›ç¨‹æ•°é‡ã€é¡µè¡¨å¼•ç”¨è®¡æ•°ã€å½“å‰çˆ¶è¿›ç¨‹çš„æ ˆç­‰ä¿¡æ¯ï¼Œä¸ºå­è¿›ç¨‹åˆ†é…åˆé€‚çš„æ ˆç©ºé—´ã€‚

    ä¸‹é¢æ˜¯ä¸€ä¸ªæ¯”è¾ƒå¸¸è§„çš„æœŸæœ›çš„æ ˆç©ºé—´åˆ†é…ç»“æœï¼š

    ```txt
    +---------------------+ <- 0x400000000000
    |    Parent Stack     |
    +---------------------+ <- 0x3FFF00000000
    |    Child 1 Stack    |
    +---------------------+ <- 0x3FFE00000000
    |    Child 2 Stack    |
    +---------------------+ <- 0x3FFD00000000
    |         ...         |
    +---------------------+
    ```

    è¿™æ ·çš„æ ˆå¸ƒå±€åœ¨å¤æ‚æƒ…å†µä¸‹å¯èƒ½ä¼šé€ æˆæ ˆå¤ç”¨ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹è¿›è¡Œ `map_range` ä¼šå¤±è´¥ï¼Œä»è€Œä½ å¯ä»¥ç»§ç»­å¯»æ‰¾åˆé€‚çš„åç§»ï¼š

    ```rust
    while elf::map_range(/* page range to be mapped */).is_err()
    {
        trace!("Map thread stack to {:#x} failed.", new_stack_base);
        new_stack_base -= STACK_MAX_SIZE; // stack grow down
    }
    ```

    ä½ ä¹Ÿå¯ä»¥ç”¨ bitmap ç­‰ç»“æ„ä½“è®°å½•æ ˆçš„é‡Šæ”¾ï¼Œæˆ–ä½¿ç”¨å…¶ä»–æ–¹å¼è¿›è¡Œåˆç†çš„åˆ†é…ã€‚

    æ­¤å¤„çš„å®ç°å¾ˆçµæ´»ï¼Œä¹Ÿæ— éœ€å®Œå…¨æŒ‰ç…§ä¸Šè¿°æ ˆè§„åˆ’è¿›è¡Œï¼Œä½ å¯ä»¥è‡ªè¡Œå¯¹ç®—æ³•æˆ–åˆ†å¸ƒè¿›è¡Œè®¾è®¡ã€‚

    !!! note "æ›´é€šç”¨çš„å®ç°"

        åœ¨æ›´å¥½çš„å®ç°ä¸­ï¼Œ`fork` å¹¶ä¸å¤åˆ¶æ•´ä¸ªæ ˆï¼Œæ“ä½œç³»ç»Ÿä¼šå¯ç”¨ `fork` åå…¨éƒ¨é¡µé¢çš„å†™ä¿æŠ¤ã€‚

        åœ¨ä»»æ„è¿›ç¨‹å°è¯•å†™å…¥æ—¶ï¼Œå†å¯¹æ•´ä¸ªé¡µé¢è¿›è¡Œå¤åˆ¶ã€‚è¿™ç§ç­–ç•¥è¢«ç§°ä¸ºå†™æ—¶å¤åˆ¶ï¼ˆCopy on Writeï¼ŒCOWï¼‰ï¼Œå®ƒå¯ä»¥å¤§å¤§å‡å°‘å†…å­˜çš„ä½¿ç”¨å’Œå¼€é”€ï¼Œæé«˜æ€§èƒ½ã€‚

### åŠŸèƒ½æµ‹è¯•

åœ¨å®Œæˆäº† `fork` çš„å®ç°åï¼Œä½ éœ€è¦é€šè¿‡å¦‚ä¸‹åŠŸèƒ½æµ‹è¯•æ¥éªŒè¯ä½ çš„å®ç°æ˜¯å¦æ­£ç¡®ï¼š

```rust
#![no_std]
#![no_main]

extern crate alloc;
extern crate lib;

use lib::*;

static mut M: u64 = 0xdeadbeef;

fn main() -> isize {
    let mut c = 32;
    let m_ptr = &raw mut M;

    // do not alloc heap before `fork`
    // which may cause unexpected behavior since we won't copy the heap in `fork`
    let pid = sys_fork();

    if pid == 0 {
        println!("I am the child process");

        assert_eq!(c, 32);

        unsafe {
            println!("child read value of M: {:#x}", *m_ptr);
            *m_ptr = 0x2333;
            println!("child changed the value of M: {:#x}", *m_ptr);
        }

        c += 32;
    } else {
        println!("I am the parent process");

        sys_stat();

        assert_eq!(c, 32);

        println!("Waiting for child to exit...");

        let ret = sys_wait_pid(pid);

        println!("Child exited with status {}", ret);

        assert_eq!(ret, 64);

        unsafe {
            println!("parent read value of M: {:#x}", *m_ptr);
            assert_eq!(*m_ptr, 0x2333);
        }

        c += 1024;

        assert_eq!(c, 1056);
    }

    c
}

entry!(main);
```

## è¿›ç¨‹çš„é˜»å¡ä¸å”¤é†’

è¿›ç¨‹çš„é˜»å¡ä¸å”¤é†’æ˜¯éå¸¸é‡è¦çš„åŠŸèƒ½ï¼Œå®ƒå¯ä»¥ç”¨äºæ§åˆ¶è¿›ç¨‹çš„æ‰§è¡Œé¡ºåºã€èµ„æºçš„åˆ†é…ã€è¿›ç¨‹çš„åŒæ­¥ç­‰ã€‚åœ¨å…ˆå‰çš„å®ç°ä¸­ï¼Œå·²ç»å®ç°äº† `wait_pid` ç³»ç»Ÿè°ƒç”¨ï¼Œå®ƒé€šè¿‡è½®è¯¢çš„æ–¹å¼æ¥ç­‰å¾…ä¸€ä¸ªè¿›ç¨‹çš„é€€å‡ºï¼Œå¹¶è¿”å›å…¶é€€å‡ºçŠ¶æ€ã€‚

ç›¸å¯¹è€Œè¨€ï¼Œè½®è¯¢ä¼šæ¶ˆè€—å¤§é‡çš„ CPU æ—¶é—´ï¼Œå› æ­¤éœ€è¦ä¸€ç§æ›´ä¸ºé«˜æ•ˆçš„æ–¹å¼æ¥è¿›è¡Œè¿›ç¨‹çš„é˜»å¡ä¸å”¤é†’ï¼š**èƒ½å¦è®©è¿›ç¨‹åœ¨ç­‰å¾…æŸä¸ªäº‹ä»¶å‘ç”Ÿæ—¶è¿›å…¥é˜»å¡çŠ¶æ€ï¼Œè€Œåœ¨äº‹ä»¶å‘ç”Ÿæ—¶å”¤é†’è¿›ç¨‹å‘¢ï¼Ÿ**

åœ¨æœ¬å®éªŒçš„è®¾è®¡ä¸­ï¼Œå¯¹äº `wait_pid` ç³»ç»Ÿè°ƒç”¨ï¼Œè¿›ç¨‹åœ¨å‘å‡ºè°ƒç”¨åï¼Œä¼šè¿›å…¥ä¸€ä¸ª**ç­‰å¾…é˜Ÿåˆ—**ï¼Œå½“è¢«ç­‰å¾…çš„è¿›ç¨‹é€€å‡ºæ—¶ï¼Œä¼šå”¤é†’ç­‰å¾…é˜Ÿåˆ—ä¸­çš„è¿›ç¨‹ã€‚

### ç­‰å¾…é˜Ÿåˆ—

åœ¨ `pkg/kernel/src/proc/manager.rs` ä¸­ï¼Œä¿®æ”¹ `ProcessManager` å¹¶æ·»åŠ ç­‰å¾…é˜Ÿåˆ—ï¼š

```rust
pub struct ProcessManager {
    // ...
    wait_queue: Mutex<BTreeMap<ProcessId, BTreeSet<ProcessId>>>,
}
```

å…¶ä¸­ï¼Œ`BTreeMap` çš„é”®å€¼å¯¹åº”äºè¢«ç­‰å¾…çš„è¿›ç¨‹ IDï¼Œ`BTreeSet` ç”¨äºå­˜å‚¨ç­‰å¾…çš„è¿›ç¨‹ ID çš„é›†åˆã€‚

### é˜»å¡è¿›ç¨‹

ä¸º `ProcessManager` æ·»åŠ  `block` å‡½æ•°ï¼Œç”¨äºå°†è¿›ç¨‹è®¾ç½®ä¸ºé˜»å¡çŠ¶æ€ï¼š

```rust
/// Block the process with the given pid
pub fn block(&self, pid: ProcessId) {
    if let Some(proc) = self.get_proc(&pid) {
        // FIXME: set the process as blocked
    }
}
```

!!! tip "è®¾ç½®è¿›ç¨‹çš„ç§æœ‰å­—æ®µ"

    `ProcessInner` ä¸­çš„ `status` å­—æ®µæ˜¯ç§æœ‰çš„ï¼Œå¯¹äºä¸€ç³»åˆ—çš„çŠ¶æ€å˜æ›´ï¼Œä½ å¯ä»¥æ·»åŠ ç›¸åº”çš„å‡½æ•°æ¥è¿›è¡Œè®¾ç½®ã€‚

    ä¾‹å¦‚ï¼Œä½ å¯ä»¥æ·»åŠ  `block` å‡½æ•°ï¼Œæ¥è®¾ç½®è¿›ç¨‹çš„çŠ¶æ€ï¼š

    ```rust
    pub fn block(&mut self) {
        self.status = ProcessStatus::Blocked;
    }
    ```

åœ¨ `pkg/kernel/src/proc/mod.rs` ä¸­ï¼Œä¿®æ”¹ `wait_pid` ç³»ç»Ÿè°ƒç”¨çš„å®ç°ï¼Œæ·»åŠ  `ProcessContext` å‚æ•°æ¥ç¡®ä¿å¯ä»¥è¿›è¡Œå¯èƒ½çš„åˆ‡æ¢ä¸Šä¸‹æ–‡æ“ä½œï¼ˆæ„å‘³ç€å½“å‰è¿›ç¨‹è¢«é˜»å¡ï¼Œéœ€è¦åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªè¿›ç¨‹ï¼‰ï¼š

```rust
pub fn wait_pid(pid: ProcessId, context: &mut ProcessContext) {
    x86_64::instructions::interrupts::without_interrupts(|| {
        let manager = get_process_manager();
        if let Some(ret) = manager.get_exit_code(pid) {
            context.set_rax(ret as usize);
        } else {
            manager.wait_pid(pid);
            manager.save_current(context);
            manager.current().write().block();
            manager.switch_next(context);
        }
    })
}
```

åŒæ—¶ä¸º `ProcessManager` æ·»åŠ  `wait_pid` å‡½æ•°ï¼š

```rust
pub fn wait_pid(&self, pid: ProcessId) {
    let mut wait_queue = self.wait_queue.lock();
    // FIXME: push the current process to the wait queue
    //        `processor::current_pid()` is waiting for `pid`
}
```

!!! tip "ä½¿ç”¨ `BTreeMap` çš„ `entry` æ–¹æ³•"

    `BTreeMap` çš„ `entry` æ–¹æ³•å¯ä»¥ç”¨äºè·å–ä¸€ä¸ªé”®å¯¹åº”çš„å€¼çš„å¯å˜å¼•ç”¨ï¼Œå¹¶å¯ä»¥é€šè¿‡ `or_default` æˆ–è€… `or_insert` æ¥æ’å…¥ä¸€ä¸ªé»˜è®¤å€¼ã€‚

    ```rust
    let mut map: BTreeMap<u32, BTreeSet<u32>> = BTreeMap::new();
    let entry = map.entry(42).or_default();
    entry.insert(2333);
    ```

### å”¤é†’è¿›ç¨‹

åœ¨é˜»å¡è¿›ç¨‹åï¼Œè¿˜éœ€è¦å¯¹è¿›ç¨‹è¿›è¡Œå”¤é†’ã€‚å¯¹äºæœ¬å¤„çš„ `wait_pid` ç³»ç»Ÿè°ƒç”¨ï¼Œå½“è¢«ç­‰å¾…çš„è¿›ç¨‹é€€å‡ºæ—¶ï¼Œéœ€è¦å”¤é†’ç­‰å¾…é˜Ÿåˆ—ä¸­çš„è¿›ç¨‹ã€‚

é¦–å…ˆï¼Œä¸º `ProcessManager` æ·»åŠ  `wake_up` å‡½æ•°ï¼š

```rust
/// Wake up the process with the given pid
///
/// If `ret` is `Some`, set the return value of the process
pub fn wake_up(&self, pid: ProcessId, ret: Option<isize>) {
    if let Some(proc) = self.get_proc(&pid) {
        let mut inner = proc.write();
        if let Some(ret) = ret {
            // FIXME: set the return value of the process
            //        like `context.set_rax(ret as usize)`
        }
        // FIXME: set the process as ready
        // FIXME: push to ready queue
    }
}
```

åœ¨è¿›ç¨‹é€€å‡ºæ—¶ï¼Œä¹Ÿå³ `kill` ç³»ç»Ÿè°ƒç”¨ä¸­ï¼Œéœ€è¦å”¤é†’ç­‰å¾…é˜Ÿåˆ—ä¸­çš„è¿›ç¨‹ã€‚ä¿®æ”¹ `ProcessManager` ä¸­çš„ `kill` å‡½æ•°ï¼š

```rust
pub fn kill(pid: ProcessId, ret: isize) {
    // ...

    if let Some(pids) = self.wait_queue.lock().remove(&pid) {
        for pid in pids {
            self.wake_up(pid, Some(ret));
        }
    }
}
```

è¿™æ ·ï¼Œå°±å®ç°äº†ä¸€ä¸ªæ— éœ€è½®è¯¢çš„è¿›ç¨‹é˜»å¡ä¸å”¤é†’æœºåˆ¶ã€‚

!!! success "é˜¶æ®µæ€§æˆæœ"

    å°è¯•åœ¨ä½ çš„ Shell ä¸­å¯åŠ¨å¦ä¸€ä¸ª Shellï¼Œç„¶ååœ¨å…¶ä¸­åˆ©ç”¨ `ps` æ‰“å°è¿›ç¨‹ä¿¡æ¯ï¼š

    **å‰ä¸€ä¸ª Shell åº”å½“è¢«é˜»å¡ (Blocked)ï¼Œç›´åˆ°åä¸€ä¸ª Shell é€€å‡ºã€‚**

## å¹¶å‘ä¸é”æœºåˆ¶

ç”±äºå¹¶å‘æ‰§è¡Œæ—¶ï¼Œçº¿ç¨‹çš„è°ƒåº¦é¡ºåºæ— æ³•é¢„çŸ¥ï¼Œè¿›è€Œé€ æˆçš„æ‰§è¡Œé¡ºåºä¸ç¡®å®šï¼Œ**æŒæœ‰å…±äº«èµ„æºçš„è¿›ç¨‹ä¹‹é—´çš„å¹¶å‘æ‰§è¡Œå¯èƒ½ä¼šå¯¼è‡´æ•°æ®çš„ä¸ä¸€è‡´**ï¼Œæœ€ç»ˆå¯¼è‡´ç›¸åŒçš„ç¨‹åºäº§ç”Ÿä¸€ç³»åˆ—ä¸åŒçš„ç»“æœï¼Œè¿™æ ·çš„æƒ…å†µè¢«ç§°ä¹‹ä¸º**ç«æ€æ¡ä»¶ï¼ˆrace conditionï¼‰**ã€‚

!!! tip "æ¡ä»¶ç«äº‰â€¦â€¦ï¼Ÿ"

    æ¶æ„ç¨‹åºåˆ©ç”¨ç±»ä¼¼çš„åŸç†ï¼Œé€šè¿‡ä¸æ–­åœ°å°è¯•ï¼Œæœ€ç»ˆç»•è¿‡æ£€æŸ¥ï¼Œè·å¾—äº†ä¸€äº›ä¸åº”è¯¥è¢«è®¿é—®çš„èµ„æºï¼Œè¿™ç§å¯¹ç³»ç»Ÿçš„æ”»å‡»è¡Œä¸ºä¹Ÿè¢«ç§°ä¸ºæ¡ä»¶ç«äº‰ã€‚

    > å®ƒä»¬çš„è‹±æ–‡ç¿»è¯‘éƒ½æ˜¯ Race Conditionï¼Œä½†åœ¨ä¸åŒçš„é¢†åŸŸå†…å¸¸ç”¨ä¸åŒçš„ç¿»è¯‘ã€‚

    ä¸€ä¸ªè‘—åçš„ä¾‹å­æ˜¯ Linux å†…æ ¸æƒé™æå‡æ¼æ´ Dirty COW (CVE-2016-5195)ï¼Œé€šè¿‡æ¡ä»¶ç«äº‰ä½¿å¾—æ™®é€šç”¨æˆ·å¯ä»¥å†™å…¥åŸæœ¬åªè¯»çš„å†…å­˜åŒºåŸŸï¼Œä»è€Œæå‡æƒé™ã€‚

è€ƒè™‘å¦‚ä¸‹çš„ä»£ç ï¼š

```rust
static mut COUNTER: usize = 0;

fn main() {
    let mut handles = vec![];

    for _ in 0..10 {
        handles.push(std::thread::spawn(|| {
            for _ in 0..1000 {
                unsafe {
                    COUNTER += 1;
                }
            }
        }));
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", unsafe { COUNTER });
}
```

!!! tip "å¯ä»¥ç›´æ¥ä½¿ç”¨ `rustc main.rs` è¿›è¡Œç¼–è¯‘"

å¾—åˆ°çš„ç»“æœå¦‚ä¸‹ï¼š

```bash
$ for ((i = 0; i < 16; i++)); do ./main; done
Result: 9595
Result: 8838
Result: 8315
Result: 7602
Result: 9120
Result: 8485
Result: 8831
Result: 8717
Result: 8812
Result: 8955
Result: 9266
Result: 8168
Result: 9159
Result: 10000
Result: 9664
Result: 10000
```

å¯ä»¥çœ‹åˆ°ï¼Œæ¯æ¬¡è¿è¡Œçš„ç»“æœéƒ½å¯èƒ½ä¸ä¸€æ ·ï¼Œè¿™æ˜¯å› ä¸º `COUNTER += 1` æ“ä½œå¹¶ä¸æ˜¯åŸå­çš„ï¼Œå®ƒåŒ…å«äº†è¯»å–ã€ä¿®æ”¹å’Œå†™å…¥ä¸‰ä¸ªæ­¥éª¤ï¼Œè€Œåœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹ï¼Œè¿™ä¸‰ä¸ªæ­¥éª¤ä¹‹é—´å¯èƒ½ä¼šè¢«å…¶ä»–çº¿ç¨‹ï¼ˆé€šè¿‡æ“ä½œç³»ç»Ÿçš„æ—¶é’Ÿä¸­æ–­æˆ–å…¶ä»–æ–¹å¼ï¼‰æ‰“æ–­ï¼Œåæ±‡ç¼–ä¸Šè¿°ä»£ç ï¼Œå¯ä»¥çœ‹åˆ° `COUNTER += 1` çš„å®é™…æ“ä½œï¼š

```nasm
mov rax, qword [obj.main::COUNTER::hfb966cd5c23908b7] # read COUNTER to rax
add rax, 1                                            # rax += 1
# ... overflow check by rustc ...
mov qword [obj.main::COUNTER::hfb966cd5c23908b7], rax # write rax to COUNTER
```

è€ƒè™‘å¦‚ä¸‹çš„æ‰§è¡Œé¡ºåºï¼ˆå®é™…æ‰§è¡Œçš„æ—¶é’Ÿä¸­æ–­ä¼šæ…¢å¾—å¤šï¼Œæ‰€ä»¥ä¸Šè¿°ä»£ç ä½¿ç”¨å¾ªç¯æ¥å‡¸æ˜¾è¿™ä¸€é—®é¢˜ï¼‰ï¼š

```nasm
# Thread 1
mov rax, qword [obj.main::COUNTER::hfb966cd5c23908b7]
add rax, 1

# !!! Context Switch !!!

# Thread 2
mov rax, qword [obj.main::COUNTER::hfb966cd5c23908b7]

# !!! Context Switch !!!

# Thread 1
mov qword [obj.main::COUNTER::hfb966cd5c23908b7], rax

# !!! Context Switch !!!

# Thread 2
add rax, 1
mov qword [obj.main::COUNTER::hfb966cd5c23908b7], rax
```

åœ¨è¿™æ ·çš„æ‰§è¡Œé¡ºåºä¸‹ï¼Œ`COUNTER` çš„å€¼ä¼šæ¯”é¢„æœŸå°‘ï¼Œå‡ ä¸ªçº¿ç¨‹å¯èƒ½ä¼šåŒæ—¶è¯»å–åˆ°ç›¸åŒçš„å€¼ï¼Œç„¶ååŒæ—¶å†™å…¥ç›¸åŒçš„å€¼ï¼Œè¿™æ ·çš„è¡Œä¸ºå°±ä¼šå¯¼è‡´ `+=` çš„è¯­æ„è¢«ç ´åã€‚

ä¸Šé¢è¿™ç§è®¿é—®å…±äº«èµ„æºçš„ä»£ç ç‰‡æ®µè¢«ç§°ä¸º**ä¸´ç•ŒåŒº**ï¼Œä¸ºäº†ä¿è¯ä¸´ç•ŒåŒºçš„æ­£ç¡®æ€§ï¼Œéœ€è¦ç¡®ä¿**æ¯æ¬¡åªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥è¿›å…¥ä¸´ç•ŒåŒº**ï¼Œä¹Ÿå³ä¿è¯è¿™éƒ¨åˆ†æŒ‡ä»¤åºåˆ—æ˜¯**äº’æ–¥**çš„ã€‚

### åŸå­æŒ‡ä»¤

ä¸€èˆ¬è€Œè¨€ï¼Œä¸ºäº†è§£å†³å¹¶å‘ä»»åŠ¡å¸¦æ¥çš„é—®é¢˜ï¼Œéœ€è¦é€šè¿‡æŒ‡ä»¤é›†ä¸­çš„åŸå­æ“ä½œæ¥ä¿è¯æ•°æ®çš„ä¸€è‡´æ€§ã€‚åœ¨ Rust ä¸­ï¼Œè¿™ç±»åŸå­æŒ‡ä»¤è¢«å°è£…åœ¨ `core::sync::atomic` æ¨¡å—ä¸­ï¼Œä½œä¸ºæ¶æ„æ— å…³çš„åŸå­æ“ä½œæ¥æä¾›å¹¶å‘å®‰å…¨æ€§ã€‚

ä»¥ `AtomicUsize` ä¸ºä¾‹ï¼Œå®ƒæä¾›äº†ä¸€ç³»åˆ—çš„åŸå­æ“ä½œï¼Œå¦‚ `fetch_add`ã€`fetch_update`ã€`compare_exchange` ç­‰ï¼Œè¿™äº›æ“ä½œéƒ½æ˜¯åŸå­çš„ï¼Œä¸ä¼šè¢«å…¶ä»–çº¿ç¨‹æ‰“æ–­ï¼Œå¯¹äºä¹‹å‰çš„ä¾‹å­ï¼š

```rust
static COUNTER: AtomicUsize = AtomicUsize::new(0);
COUNTER.fetch_add(1, Ordering::SeqCst);
```

å…¶ä¸­ `Ordering` ç”¨æˆ·æ§åˆ¶å†…å­˜é¡ºåºï¼Œåœ¨å•æ ¸æƒ…å†µä¸‹ï¼Œ`Ordering` çš„é€‰æ‹©å¹¶ä¸ä¼šå½±å“ç¨‹åºçš„è¡Œä¸ºï¼Œå¯ä»¥ç®€å•äº†è§£ï¼Œå¹¶å°è¯•å›ç­”æ€è€ƒé¢˜ 4 çš„å†…å®¹ã€‚

åœ¨ç¼–è¯‘å™¨ä¼˜åŒ–åå°†ä¼šè¢«ç¼–è¯‘ä¸ºï¼š

```nasm
lock inc qword [obj.main::COUNTER::h2889e4585a2a2d30]
```

è¿™å°±æ˜¯ä¸€å¥åŸå­çš„ `inc` æŒ‡ä»¤ï¼Œä¸­æ–­æˆ–ä»»åŠ¡åˆ‡æ¢éƒ½ä¸ä¼šæ‰“æ–­è¿™ä¸ªæŒ‡ä»¤çš„æ‰§è¡Œï¼Œä»è€Œä¿è¯äº† `COUNTER` çš„ä¸€è‡´æ€§ã€‚

åœ¨äº†è§£äº†åŸå­æŒ‡ä»¤çš„åŸºæœ¬æ¦‚å¿µåï¼Œå¯ä»¥åˆ©ç”¨å®ƒæ¥ä¸ºç”¨æˆ·æ€ç¨‹åºæä¾›ä¸¤ç§ç®€å•çš„åŒæ­¥æ“ä½œï¼šè‡ªæ—‹é” `SpinLock` å’Œä¿¡å·é‡ `Semaphore`ã€‚å…¶ä¸­è‡ªæ—‹é”çš„å®ç°å¹¶ä¸éœ€è¦å†…æ ¸æ€çš„æ”¯æŒï¼Œè€Œä¿¡å·é‡åˆ™ä¼šæ¶‰åŠåˆ°è¿›ç¨‹è°ƒåº¦ç­‰æ“ä½œï¼Œéœ€è¦å†…æ ¸æ€çš„æ”¯æŒã€‚

æ­£å› å¦‚æ­¤ï¼Œåœ¨è¿›è¡Œå†…æ ¸ç¼–å†™çš„è¿‡ç¨‹ä¸­é‡åˆ°çš„ `Mutex` å’Œ `RwLock` ç­‰ç”¨äºä¿éšœå†…æ ¸æ€æ•°æ®ä¸€è‡´æ€§çš„é”æœºåˆ¶**å‡æ˜¯åŸºäºè‡ªæ—‹é”å®ç°çš„**ï¼Œ_ä½ å¯èƒ½åœ¨ä¹‹å‰çš„å®éªŒä¸­é‡åˆ°è¿‡ç³»ç»Ÿå› ä¸ºè‡ªæ—‹å¿™ç­‰å¾…å¯¼è‡´çš„å¼‚å¸¸æƒ…å†µ_ã€‚

### è‡ªæ—‹é”

è‡ªæ—‹é” `SpinLock` æ˜¯ä¸€ç§ç®€å•çš„é”æœºåˆ¶ï¼Œå®ƒé€šè¿‡ä¸æ–­åœ°æ£€æŸ¥é”çš„çŠ¶æ€æ¥å®ç°çº¿ç¨‹çš„é˜»å¡ï¼Œç›´åˆ°è·å–åˆ°é”ä¸ºæ­¢ã€‚

åœ¨ `pkg/lib/src/sync.rs` ä¸­ï¼Œå…³æ³¨ `SpinLock` çš„å®ç°ï¼š

```rust
pub struct SpinLock {
    bolt: AtomicBool,
}

impl SpinLock {
    pub const fn new() -> Self {
        Self {
            bolt: AtomicBool::new(false),
        }
    }

    pub fn acquire(&mut self) {
        // FIXME: acquire the lock, spin if the lock is not available
    }

    pub fn release(&mut self) {
        // FIXME: release the lock
    }
}

// Why? Check reflection question 5
unsafe impl Sync for SpinLock {}
```

åœ¨å®ç° `acquire` å’Œ `release` æ—¶ï¼Œä½ éœ€è¦ä½¿ç”¨ `AtomicBool` çš„åŸå­æ“ä½œæ¥ä¿è¯é”çš„æ­£ç¡®æ€§ï¼š

-   `load` å‡½æ•°ç”¨äºè¯»å–å½“å‰å€¼ã€‚
-   `store` å‡½æ•°ç”¨äºè®¾ç½®æ–°å€¼ã€‚
-   `compare_exchange` å‡½æ•°ç”¨äºåŸå­åœ°è¿›è¡Œæ¯”è¾ƒ-äº¤æ¢ï¼Œä¹Ÿå³æ¯”è¾ƒå½“å‰å€¼æ˜¯å¦ä¸ºç›®æ ‡å€¼ï¼Œå¦‚æœæ˜¯åˆ™å°†å…¶è®¾ç½®ä¸ºæ–°å€¼ï¼Œå¦åˆ™è¿”å›å½“å‰å€¼ã€‚

åœ¨è¿›è¡Œå¾ªç¯ç­‰å¾…æ—¶ï¼Œå¯ä»¥ä½¿ç”¨ `core::hint::spin_loop` æé«˜æ€§èƒ½ï¼Œåœ¨ x86_64 æ¶æ„ä¸­ï¼Œå®ƒå®é™…ä¸Šä¼šç¼–è¯‘ä¸º `pause` æŒ‡ä»¤ã€‚

### ä¿¡å·é‡

å¾—åˆ©äº Rust è‰¯å¥½çš„åº•å±‚å°è£…ï¼Œè‡ªæ—‹é”çš„å®ç°éå¸¸ç®€å•ã€‚ä½†æ˜¯ä¹Ÿå­˜åœ¨ä¸€å®šçš„é—®é¢˜ï¼š

-   å¿™ç­‰å¾…ï¼šè‡ªæ—‹é”ä¼šä¸€ç›´å ç”¨ CPU æ—¶é—´ï¼Œç›´åˆ°è·å–åˆ°é”ä¸ºæ­¢ï¼Œè¿™ä¼šå¯¼è‡´ CPU åˆ©ç”¨ç‡çš„ä¸‹é™ã€‚
-   é¥¥é¥¿ï¼šå¦‚æœä¸€ä¸ªçº¿ç¨‹ä¸€ç›´å ç”¨é”ï¼Œå…¶ä»–çº¿ç¨‹å¯èƒ½ä¼šä¸€ç›´æ— æ³•è·å–åˆ°é”ã€‚
-   æ­»é”ï¼šå¦‚æœä¸¤ä¸ªçº¿ç¨‹äº’ç›¸ç­‰å¾…å¯¹æ–¹å æœ‰çš„é”ï¼Œå°±ä¼šå¯¼è‡´æ­»é”ã€‚

ä¿¡å·é‡ `Semaphore` æ˜¯ä¸€ç§æ›´ä¸ºå¤æ‚çš„åŒæ­¥æœºåˆ¶ï¼Œå®ƒå¯ä»¥ç”¨äºæ§åˆ¶å¯¹å…±äº«èµ„æºçš„è®¿é—®ï¼Œä¹Ÿå¯ä»¥ç”¨äºæ§åˆ¶å¯¹ä¸´ç•ŒåŒºçš„è®¿é—®ã€‚é€šè¿‡ä¸è¿›ç¨‹è°ƒåº¦ç›¸å…³çš„æ“ä½œï¼Œä¿¡å·é‡è¿˜å¯ä»¥ç”¨äºæ§åˆ¶è¿›ç¨‹çš„æ‰§è¡Œé¡ºåºã€æé«˜ CPU åˆ©ç”¨ç‡ç­‰ã€‚

ä¿¡å·é‡éœ€è¦å®ç°å››ç§æ“ä½œï¼š

-   `new`ï¼šæ ¹æ®æ‰€ç»™å‡ºçš„ `key` åˆ›å»ºä¸€ä¸ªæ–°çš„ä¿¡å·é‡ã€‚
-   `remove`ï¼šæ ¹æ®æ‰€ç»™å‡ºçš„ `key` åˆ é™¤ä¸€ä¸ªå·²ç»å­˜åœ¨çš„ä¿¡å·é‡ã€‚
-   `signal`ï¼šä¹Ÿå«åš `V` æ“ä½œï¼Œä¹Ÿå¯ä»¥è¢« `release/up/verhogen` è¡¨ç¤ºï¼Œå®ƒç”¨äºé‡Šæ”¾ä¸€ä¸ªèµ„æºï¼Œä½¿å¾—ç­‰å¾…çš„è¿›ç¨‹å¯ä»¥ç»§ç»­æ‰§è¡Œã€‚
-   `wait`ï¼šä¹Ÿå«åš `P` æ“ä½œï¼Œä¹Ÿå¯ä»¥è¢« `acquire/down/proberen` è¡¨ç¤ºï¼Œå®ƒç”¨äºè·å–ä¸€ä¸ªèµ„æºï¼Œå¦‚æœèµ„æºä¸å¯ç”¨ï¼Œåˆ™è¿›ç¨‹å°†ä¼šè¢«é˜»å¡ã€‚

ä¸ºäº†å®ç°ä¸å†…æ ¸çš„äº¤äº’ï¼Œä¿¡å·é‡çš„æ“ä½œå°†è¢«å®ç°ä¸ºä¸€ä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œå®ƒå°†ä½¿ç”¨åˆ°ä¸‰ä¸ªç³»ç»Ÿè°ƒç”¨å‚æ•°ï¼š

```rust
// op: u8, key: u32, val: usize -> ret: any
Syscall::Sem => sys_sem(&args, context),
```

å…¶ä¸­ `op` ä¸ºæ“ä½œç ï¼Œ`key` ä¸ºä¿¡å·é‡çš„é”®å€¼ï¼Œ`val` ä¸ºä¿¡å·é‡çš„å€¼ï¼Œ`ret` ä¸ºè¿”å›å€¼ã€‚æ ¹æ®å…ˆå‰çš„çº¦å®šï¼Œ`op` è¢«æ”¾ç½®åœ¨ `rdi` å¯„å­˜å™¨ä¸­ï¼Œ`key` å’Œ `val` åˆ†åˆ«è¢«æ”¾ç½®åœ¨ `rsi` å’Œ `rdx` å¯„å­˜å™¨ä¸­ï¼Œå¯ä»¥é€šè¿‡ `args.arg0`ã€`args.arg1` å’Œ `args.arg2` æ¥è¿›è¡Œè®¿é—®ã€‚

ä¿¡å·é‡ç›¸å…³å†…å®¹åœ¨ `pkg/kernel/src/proc/sync.rs` ä¸­è¿›è¡Œå®ç°ï¼š

â€œèµ„æºâ€ è¢«æŠ½è±¡ä¸ºä¸€ä¸ª `usize` æ•´æ•°ï¼Œå®ƒ**å¹¶ä¸éœ€è¦ä½¿ç”¨ `AtomicUsize`**ï¼Œä¸ºäº†å­˜å‚¨ç­‰å¾…çš„è¿›ç¨‹ï¼Œéœ€è¦åœ¨æ­¤æ•´æ•°å¤–é¢å¤–ä½¿ç”¨ä¸€ä¸ª `Vec` æ¥å­˜å‚¨ç­‰å¾…çš„è¿›ç¨‹ã€‚å®ƒä»¬äºŒè€…å°†ä¼šè¢«ä¸€ä¸ªè‡ªæ—‹é”å®ç°çš„äº’æ–¥é”ï¼ˆåœ¨å†…æ ¸ä¸­ç›´æ¥ä½¿ç”¨ `spin::Mutex`ï¼‰ä¿æŠ¤ã€‚

```rust
pub struct Semaphore {
    count: usize,
    wait_queue: VecDeque<ProcessId>,
}
```

ä¿¡å·é‡æ“ä½œçš„ç»“æœä½¿ç”¨ `SemaphoreResult` è¡¨ç¤ºï¼š

```rust
pub enum SemaphoreResult {
    Ok,
    NotExist,
    Block(ProcessId),
    WakeUp(ProcessId),
}
```

-   `Ok`ï¼šè¡¨ç¤ºæ“ä½œæˆåŠŸï¼Œä¸”æ— éœ€è¿›è¡Œé˜»å¡æˆ–å”¤é†’ã€‚
-   `NotExist`ï¼šè¡¨ç¤ºä¿¡å·é‡ä¸å­˜åœ¨ã€‚
-   `Block(ProcessId)`ï¼šè¡¨ç¤ºæ“ä½œéœ€è¦é˜»å¡çº¿ç¨‹ï¼Œä¸€èˆ¬æ˜¯å½“å‰è¿›ç¨‹ã€‚
-   `WakeUp(ProcessId)`ï¼šè¡¨ç¤ºæ“ä½œéœ€è¦å”¤é†’çº¿ç¨‹ã€‚

ä¸ºäº†å®ç°ä¿¡å·é‡çš„ KV å­˜å‚¨ï¼Œä½¿ç”¨ `SemaphoreSet` å®šä¹‰ä¿¡å·é‡é›†åˆçš„æ“ä½œï¼š

```rust
pub struct SemaphoreSet {
    sems: BTreeMap<SemaphoreId, Mutex<Semaphore>>,
}
```

å¹¶åœ¨ `ProcessData` ä¸­æ·»åŠ ä¸ºçº¿ç¨‹å…±äº«èµ„æºï¼š

```rust
pub struct ProcessData {
    // ...
    pub(super) semaphores: Arc<RwLock<SemaphoreSet>>,
    // ...
}
```

!!! note "å…³äºè¿™é‡Œçš„ä¸€å †é”â€¦â€¦"

    åœ¨æœ¬å®éªŒå®ç°çš„å•æ ¸å¤„ç†å™¨ä¸‹ï¼Œ`Semaphore` çš„å®ç°ä¼¼ä¹å¹¶ä¸éœ€è¦å†…éƒ¨çš„ `Mutex` è¿›è¡Œä¿æŠ¤ï¼Œåªéœ€è¦å¤–éƒ¨çš„ `RwLock` è¿›è¡Œä¿æŠ¤å³å¯ã€‚

    ä½†åœ¨å¤šæ ¸å¤„ç†å™¨ä¸‹ï¼Œ`Semaphore` çš„å®ç°å¯èƒ½ä¼šæ¶‰åŠåˆ°å¤šä¸ªæ ¸å¿ƒçš„å¹¶å‘è®¿é—®ï¼Œå› æ­¤éœ€è¦ä½¿ç”¨ `Mutex` æ¥æä¾›æ›´ç»†ç²’åº¦çš„é”ä¿æŠ¤ã€‚åœ¨è¿›è¡Œæ·»åŠ ã€åˆ é™¤æ“ä½œæ—¶ï¼Œå¯¹ `RwLock` ä½¿ç”¨ `write` è·å–å†™é”ï¼Œè€Œåœ¨è¿›è¡Œ `signal`ã€`wait` æ“ä½œæ—¶ï¼Œå¯¹ `RwLock` ä½¿ç”¨ `read` æ¥è·å–æ›´å¥½çš„æ€§èƒ½å’Œæ§åˆ¶ã€‚

    ç»¼ä¸Šè€ƒé‡ï¼Œè¿™é‡Œå°±ä¿ç•™äº† `Mutex` çš„ä½¿ç”¨ã€‚

ç”±äºä¿¡å·é‡ä¼šé˜»å¡è¿›ç¨‹ï¼Œæ‰€ä»¥éœ€è¦åœ¨ç³»ç»Ÿè°ƒç”¨çš„å¤„ç†ä¸­æŒ‰ç…§ä¿¡å·é‡çš„è¿”å›å€¼è¿›è¡Œç›¸å…³è¿›ç¨‹æ“ä½œï¼Œä¸€ä¸ªä»£ç ç¤ºä¾‹å¦‚ä¸‹ï¼š

```rust
pub fn sem_wait(key: u32, context: &mut ProcessContext) {
    x86_64::instructions::interrupts::without_interrupts(|| {
        let manager = get_process_manager();
        let pid = processor::current_pid();
        let ret = manager.current().write().sem_wait(key, pid);
        match ret {
            SemaphoreResult::Ok => context.set_rax(0),
            SemaphoreResult::NotExist => context.set_rax(1),
            SemaphoreResult::Block(pid) => {
                // FIXME: save, block it, then switch to next
                //        use `save_current` and `switch_next`
            }
            _ => unreachable!(),
        }
    })
}
```

è¯·å‚è€ƒå®éªŒä»£ç ç»™å‡ºçš„ç›¸å…³æ³¨é‡Šå†…å®¹ï¼Œå®Œæˆä¿¡å·é‡çš„å®ç°ã€ä¸åŒæ“ä½œçš„ç³»ç»Ÿè°ƒç”¨æœåŠ¡å®ç°ï¼Œæœ€åå®Œå–„ä½œä¸ºç³»ç»Ÿè°ƒç”¨çš„ `sys_sem`ï¼š

```rust
pub fn sys_sem(args: &SyscallArgs, context: &mut ProcessContext) {
    match args.arg0 {
        0 => context.set_rax(new_sem(args.arg1 as u32, args.arg2)),
        1 => context.set_rax(remove_sem(args.arg1 as u32)),
        2 => sem_signal(args.arg1 as u32, context),
        3 => sem_wait(args.arg1 as u32, context),
        _ => context.set_rax(usize::MAX),
    }
}
```

!!! tip "è¿›ç¨‹çš„å”¤é†’"

    ä¸ `wait_pid` ç³»ç»Ÿè°ƒç”¨ç±»ä¼¼ï¼Œä½ éœ€è¦åœ¨ `sem_signal` ä¸­å¯¹è¿›ç¨‹è¿›è¡Œå”¤é†’ã€‚

    ä½†æ˜¯æ­¤å¤„æ— éœ€ä¸ºè¿›ç¨‹è®¾ç½®è¿”å›å€¼ï¼Œå› æ­¤åœ¨è°ƒç”¨ `wake_up` æ—¶ï¼Œä¼ å…¥ `None` å³å¯ã€‚

!!! tip "å®Œå–„ç”¨æˆ·åº“"

    å®Œå–„ `pkg/lib/src/sync.rs` ä¸­æœ‰å…³ä¿¡å·é‡çš„æ“ä½œï¼Œä½¿ç”¨ä¸åŒçš„ `op` å‚æ•°æ¥è¿›è¡Œä¿¡å·é‡çš„ç”¨æˆ·æ€å‡½æ•°çš„åˆ†é…ï¼Œç³»ç»Ÿè°ƒç”¨å®éœ€è¦å°†å‚æ•°è½¬æ¢ä¸º `usize` ç±»å‹ï¼Œå¯ä»¥å‚è€ƒå¦‚ä¸‹å£°æ˜ï¼š

    ```rust
    #[inline(always)]
    pub fn sys_new_sem(key: u32, value: usize) -> bool {
        syscall!(Syscall::Sem, 0, key as usize, value) == 0
    }
    ```

### æµ‹è¯•ä»»åŠ¡

åœ¨å®ç°äº† `SpinLock` å’Œ `Semaphore` çš„åŸºç¡€ä¸Šï¼Œä½ éœ€è¦å®Œæˆå¦‚ä¸‹çš„ç”¨æˆ·ç¨‹åºä»»åŠ¡æ¥æµ‹è¯•ä½ çš„å®ç°ï¼š

#### å¤šçº¿ç¨‹è®¡æ•°å™¨

åœ¨æ‰€ç»™ä»£ç çš„ `pkg/app/counter` ä¸­å®ç°äº†ä¸€ä¸ªå¤šçº¿ç¨‹è®¡æ•°å™¨ï¼Œå¤šä¸ªçº¿ç¨‹å¯¹ä¸€ä¸ªå…±äº«çš„è®¡æ•°å™¨è¿›è¡Œç´¯åŠ æ“ä½œï¼Œæœ€ç»ˆè¾“å‡ºè®¡æ•°å™¨çš„å€¼ã€‚

ä¸ºäº†æä¾›è¶³å¤Ÿå¤§çš„å¯èƒ½æ€§æ¥è§¦å‘ç«æ€æ¡ä»¶ï¼Œè¯¥ç¨‹åºä½¿ç”¨äº†ä¸€äº›æ‰‹æ®µæ¥åˆ»æ„æ„é€ ä¸€ä¸ªä¸´ç•ŒåŒºï¼Œè¿™éƒ¨åˆ†ä»£ç ä¸åº”è¢«ä¿®æ”¹ã€‚

ä½ éœ€è¦é€šè¿‡ä¸Šè¿°**ä¸¤ç§æ–¹å¼**ï¼Œåˆ†åˆ«ä¿æŠ¤è¯¥ä¸´ç•ŒåŒºï¼Œä½¿å¾—è®¡æ•°å™¨çš„å€¼æœ€ç»ˆä¸º `800`ã€‚

!!! question "å¦‚ä½•å£°æ˜é”å˜é‡æ‰èƒ½è®©å®ƒåœ¨è¿›ç¨‹é—´å…±äº«ï¼Ÿæ ¹æ®ä¸Šæ–‡çš„å®ç°å’Œä½ çš„ç†è§£ï¼Œè®©å®ƒä»¬æ­£ç¡®å‘æŒ¥ä½œç”¨ã€‚"

!!! note "å°è¯•ä¿®æ”¹ä»£ç ï¼Œä½¿ç”¨**ä¸¤ç»„çº¿ç¨‹**åˆ†åˆ«æµ‹è¯• `SpinLock` å’Œ `Semaphore`"

    ä¸€ä¸ªå‚è€ƒä»£ç è¡Œä¸ºå¦‚ä¸‹ï¼Œä½ å¯ä»¥å‚è€ƒè¿™ç§å½¢å¼ä¿®æ”¹å’Œç¼–å†™æµ‹è¯•ç¨‹åºï¼Œè€Œæ— éœ€åˆ†æˆä¸¤ä¸ªç”¨æˆ·ç¨‹åºï¼š

    ```rust
    fn main() -> isize {
        let pid = sys_fork();

        if pid == 0 {
            test_semaphore();
        } else {
            test_spin();
            sys_wait_pid(pid);
        }

        0
    }
    ```

    ä½ å¯ä»¥åœ¨ `test_spin` å’Œ `test_semaphore` ä¸­åˆ†åˆ«ç»§ç»­ `fork` æ›´å¤šçš„è¿›ç¨‹ç”¨æ¥å®é™…æµ‹è¯•ã€‚

#### æ¶ˆæ¯é˜Ÿåˆ—

åˆ›å»ºä¸€ä¸ªç”¨æˆ·ç¨‹åº `pkg/app/mq`ï¼Œç»“åˆä½¿ç”¨ä¿¡å·é‡ï¼Œå®ç°ä¸€ä¸ªæ¶ˆæ¯é˜Ÿåˆ—ï¼š

-   çˆ¶è¿›ç¨‹ä½¿ç”¨ fork åˆ›å»ºé¢å¤–çš„ 16 ä¸ªè¿›ç¨‹ï¼Œå…¶ä¸­ä¸€åŠä¸ºç”Ÿäº§è€…ï¼Œä¸€åŠä¸ºæ¶ˆè´¹è€…ã€‚

-   ç”Ÿäº§è€…ä¸æ–­åœ°å‘æ¶ˆæ¯é˜Ÿåˆ—ä¸­å†™å…¥æ¶ˆæ¯ï¼Œæ¶ˆè´¹è€…ä¸æ–­åœ°ä»æ¶ˆæ¯é˜Ÿåˆ—ä¸­è¯»å–æ¶ˆæ¯ã€‚

-   æ¯ä¸ªçº¿ç¨‹å¤„ç†çš„æ¶ˆæ¯æ€»é‡å…± 10 æ¡ã€‚

    å³ç”Ÿäº§è€…ä¼šäº§ç”Ÿ 10 ä¸ªæ¶ˆæ¯ï¼Œæ¯ä¸ªæ¶ˆè´¹è€…åªæ¶ˆè´¹ 10 ä¸ªæ¶ˆæ¯ã€‚

-   åœ¨æ¯ä¸ªçº¿ç¨‹ç”Ÿäº§æˆ–æ¶ˆè´¹çš„æ—¶å€™ï¼Œè¾“å‡ºç›¸å…³çš„ä¿¡æ¯ã€‚

    ä½ å¯èƒ½éœ€è¦ä½¿ç”¨ä¿¡å·é‡æˆ–æ—‹é”æ¥å®ç°ä¸€ä¸ªäº’æ–¥é”ï¼Œä¿è¯æ“ä½œå’Œä¿¡æ¯è¾“å‡ºä¹‹é—´ä¸ä¼šè¢«æ‰“æ–­ã€‚

-   åœ¨ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…å®Œæˆä¸Šè¿°æ“ä½œåï¼Œä½¿ç”¨ `sys_exit(0)` ç›´æ¥é€€å‡ºã€‚

-   æœ€ç»ˆä½¿ç”¨çˆ¶è¿›ç¨‹ç­‰å¾…å…¨éƒ¨çš„å­è¿›ç¨‹é€€å‡ºåï¼Œè¾“å‡ºæ¶ˆæ¯é˜Ÿåˆ—çš„æ¶ˆæ¯æ•°é‡ã€‚

-   åœ¨çˆ¶è¿›ç¨‹åˆ›å»ºå®Œæˆ 16 ä¸ªè¿›ç¨‹åï¼Œä½¿ç”¨ `sys_stat` è¾“å‡ºå½“å‰çš„å…¨éƒ¨è¿›ç¨‹çš„ä¿¡æ¯ã€‚

ä½ éœ€è¦ä¿è¯æœ€ç»ˆæ¶ˆæ¯é˜Ÿåˆ—ä¸­çš„æ¶ˆæ¯æ•°é‡ä¸º 0ï¼Œä½ å¯ä»¥å¼€å¯å†…æ ¸æ›´åŠ è¯¦ç»†çš„æ—¥å¿—ï¼Œå¹¶ä½¿ç”¨è¾“å‡ºçš„ç›¸å…³ä¿¡æ¯å°è¯•è¯æ˜é˜Ÿåˆ—çš„æ­£å¸¸å·¥ä½œï¼š

-   åœ¨ä»é˜Ÿåˆ—å–å‡ºæ¶ˆæ¯æ—¶ï¼Œæ¶ˆæ¯ä¸ºç©ºå—ï¼Ÿ
-   åœ¨å‘é˜Ÿåˆ—å†™å…¥æ¶ˆæ¯æ—¶ï¼Œé˜Ÿåˆ—æ˜¯å¦æ»¡äº†ï¼Ÿ
-   åœ¨é˜Ÿåˆ—ä¸ºç©ºæ—¶ï¼Œæ¶ˆè´¹è€…æ˜¯å¦è¢«é˜»å¡ï¼Ÿ
-   åœ¨é˜Ÿåˆ—æ»¡æ—¶ï¼Œç”Ÿäº§è€…æ˜¯å¦è¢«é˜»å¡ï¼Ÿ

!!! question "åˆ†åˆ«è®¾ç½®é˜Ÿåˆ—å®¹é‡ä¸º `1, 4, 8, 16`ï¼Œè®°å½•è§‚å¯Ÿç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…çš„è¡Œä¸ºï¼š"

    1. é˜Ÿåˆ—çš„å…ƒç´ è®¡æ•°æ˜¯å¦æ²¡æœ‰è¶…è¿‡å®¹é‡ï¼Ÿ
    2. ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…æ˜¯å¦èƒ½å¤Ÿäº¤æ›¿å·¥ä½œï¼Ÿ
    3. å°è¯•è§‚å¯Ÿåˆ°å¤šä¸ªç”Ÿäº§è€…æˆ–æ¶ˆè´¹è€…åŒæ—¶è¿›è¡ŒåŒç§æ“ä½œçš„æƒ…å†µã€‚

#### å“²å­¦å®¶çš„æ™šé¥­

å‡è®¾æœ‰ 5 ä¸ªå“²å­¦å®¶ï¼Œä»–ä»¬çš„ç”Ÿæ´»åªæ˜¯æ€è€ƒå’Œåƒé¥­ã€‚è¿™äº›å“²å­¦å®¶å…±ç”¨ä¸€ä¸ªåœ†æ¡Œï¼Œæ¯ä½éƒ½æœ‰ä¸€æŠŠæ¤…å­ã€‚åœ¨æ¡Œå­ä¸­å¤®æœ‰ä¸€ç¢—ç±³é¥­ï¼Œåœ¨æ¡Œå­ä¸Šæ”¾ç€ 5 æ ¹ç­·å­ã€‚

å½“ä¸€ä½å“²å­¦å®¶æ€è€ƒæ—¶ï¼Œä»–ä¸å…¶ä»–åŒäº‹ä¸äº¤æµã€‚æ—¶è€Œï¼Œä»–ä¼šæ„Ÿåˆ°é¥¥é¥¿ï¼Œå¹¶è¯•å›¾æ‹¿èµ·ä¸ä»–ç›¸è¿‘çš„ä¸¤æ ¹ç­·å­ï¼ˆç­·å­åœ¨ä»–å’Œä»–çš„å·¦æˆ–å³é‚»å±…ä¹‹é—´ï¼‰ã€‚

ä¸€ä¸ªå“²å­¦å®¶ä¸€æ¬¡åªèƒ½æ‹¿èµ·ä¸€æ ¹ç­·å­ã€‚æ˜¾ç„¶ï¼Œä»–ä¸èƒ½ä»å…¶ä»–å“²å­¦å®¶æ‰‹é‡Œæ‹¿èµ°ç­·å­ã€‚å½“ä¸€ä¸ªé¥¥é¥¿çš„å“²å­¦å®¶åŒæ—¶æ‹¥æœ‰ä¸¤æ ¹ç­·å­æ—¶ï¼Œä»–å°±èƒ½åƒã€‚åœ¨åƒå®Œåï¼Œä»–ä¼šæ”¾ä¸‹ä¸¤æ ¹ç­·å­ï¼Œå¹¶å¼€å§‹æ€è€ƒã€‚

åˆ›å»ºä¸€ä¸ªç”¨æˆ·ç¨‹åº `pkg/app/dinner`ï¼Œä½¿ç”¨è¯¾ä¸Šå­¦åˆ°çš„çŸ¥è¯†ï¼Œå®ç°å¹¶è§£å†³å“²å­¦å®¶å°±é¤é—®é¢˜ï¼š

-   åˆ›å»ºä¸€ä¸ªç¨‹åºï¼Œæ¨¡æ‹Ÿäº”ä¸ªå“²å­¦å®¶çš„è¡Œä¸ºã€‚

-   æ¯ä¸ªå“²å­¦å®¶éƒ½æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„çº¿ç¨‹ï¼Œå¯ä»¥åŒæ—¶è¿›è¡Œæ€è€ƒå’Œå°±é¤ã€‚

-   ä½¿ç”¨äº’æ–¥é”æ¥ä¿æŠ¤æ¯ä¸ªç­·å­ï¼Œç¡®ä¿åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªå“²å­¦å®¶å¯ä»¥æ‹¿èµ·ä¸€æ ¹ç­·å­ã€‚

-   ä½¿ç”¨ç­‰å¾…æ“ä½œè°ƒæ•´å“²å­¦å®¶çš„æ€è€ƒå’Œå°±é¤æ—¶é—´ï¼Œä»¥å¢åŠ å¹¶å‘æ€§å’Œå®é™…æ€§ã€‚

    -   å¦‚æœä½ å®ç°äº† `sys_time` ç³»ç»Ÿè°ƒç”¨ï¼ˆLab 4ï¼‰ï¼Œå¯ä»¥ä½¿ç”¨å®ƒæ¥æ„é€  `sleep` æ“ä½œã€‚
    -   å¦‚æœä½ å¹¶æ²¡æœ‰å®ç°å®ƒï¼Œå¯ä»¥å‚è€ƒå¤šçº¿ç¨‹è®¡æ•°å™¨ä¸­çš„ `delay` å‡½æ•°è¿›è¡Œå®ç°ã€‚

-   å½“å“²å­¦å®¶æˆåŠŸå°±é¤æ—¶ï¼Œè¾“å‡ºç›¸å…³ä¿¡æ¯ï¼Œå¦‚å“²å­¦å®¶ç¼–å·ã€å°±é¤æ—¶é—´ç­‰ã€‚

-   å‘ç¨‹åºä¸­å¼•å…¥ä¸€äº›éšæœºæ€§ï¼Œä¾‹å¦‚åœ¨å°è¯•æ‹¿ç­·å­æ—¶å¼•å…¥ä¸€å®šçš„å»¶è¿Ÿï¼Œæ¨¡æ‹Ÿç«äº‰æ¡ä»¶å’Œèµ„æºäº‰ç”¨ã€‚

-   å¯ä»¥è®¾ç½®ç­‰å¾…æ—¶é—´æˆ–å¾ªç¯æ¬¡æ•°ï¼Œä»¥ç¡®ä¿ç¨‹åºèƒ½å¤Ÿè¿è¡Œè¶³å¤Ÿé•¿çš„æ—¶é—´ï¼Œå¹¶å°è¯•è§‚å¯Ÿåˆ°ä¸åŒçš„æƒ…å†µï¼Œå¦‚æ­»é”å’Œé¥¥é¥¿ã€‚

??? tip "åœ¨ç”¨æˆ·æ€ä¸­å¼•å…¥ä¼ªéšæœºæ•°"

    Rust æä¾›äº†ä¸€äº›ä¼ªéšæœºæ•°ç”Ÿæˆå™¨ï¼Œä½ å¯ä»¥ä½¿ç”¨ `rand` åº“æ¥å¼•å…¥ä¸€äº›éšæœºæ€§ï¼Œä»¥æ¨¡æ‹Ÿä¸åŒçš„æƒ…å†µã€‚

    ```toml
    [dependencies]
    rand = { version = "0.8", default-features = false }
    rand_chacha = { version = "0.3", default-features = false }
    ```

    åœ¨æ— æ ‡å‡†åº“çš„ç¯å¢ƒä¸‹ï¼Œä½ éœ€è¦ä¸ºä¼ªéšæœºæ•°ç”Ÿæˆå™¨æä¾›ç§å­ã€‚

    å¦‚æœä½ å®ç°äº† `sys_time` ç³»ç»Ÿè°ƒç”¨ï¼Œè¿™ä¼šæ˜¯ä¸€ä¸ªå¾ˆæ–¹ä¾¿çš„ç§å­ã€‚

    å¦‚æœä½ æ²¡æœ‰å®ç°ï¼Œä¸å¦¨è¯•è¯•ä½¿ç”¨ `sys_getpid` æˆ–è€… `fork` é¡ºåºç­‰æ•°æ®ä½œä¸ºç§å­æ¥ç”Ÿæˆéšæœºæ•°ã€‚

    ä½ å¯ä»¥å°†ä¸Šè¿°åŠŸèƒ½å°è£…åˆ°ç”¨æˆ·åº“ä¸­ï¼Œä»¥ä¾¿åœ¨ç”¨æˆ·ç¨‹åºä¸­ä½¿ç”¨ã€‚

    ä»¥ `ChaCha20Rng` ä¼ªéšæœºæ•°ç”Ÿæˆå™¨ä¸ºä¾‹ï¼Œä½¿ç”¨ç›¸å…³æ–¹æ³•è·å–éšæœºæ•°ï¼š

    ```rust
    use rand::prelude::*;
    use rand_chacha::ChaCha20Rng;

    fn main() {
        // ...
        let time = lib::sys_time();
        let mut rng = ChaCha20Rng::seed_from_u64(time.timestamp() as u64);
        println!("Random number: {}", rng.gen::<u64>());
        // ...
    }
    ```

    ç›¸å…³æ–‡æ¡£è¯·æŸ¥é˜…ï¼š[The Rust Rand Book](https://rust-random.github.io/book/)

é€šè¿‡è§‚å¯Ÿç¨‹åºçš„è¾“å‡ºå’Œè¡Œä¸ºï¼Œè¯·å°è¯•æ„é€ å¹¶æˆªå›¾è®°å½•ä»¥ä¸‹ç°è±¡ï¼š

-   æŸäº›å“²å­¦å®¶èƒ½å¤ŸæˆåŠŸå°±é¤ï¼Œå³åŒæ—¶æ‹¿åˆ°å·¦å³ä¸¤ä¾§çš„ç­·å­ã€‚
-   å°è¯•æ„é€ æ­»é”æƒ…å†µï¼Œå³æ‰€æœ‰å“²å­¦å®¶éƒ½æ— æ³•åŒæ—¶æ‹¿åˆ°ä»–ä»¬éœ€è¦çš„ç­·å­ã€‚
-   å°è¯•æ„é€ é¥¥é¥¿æƒ…å†µï¼Œå³æŸäº›å“²å­¦å®¶æ— æ³•è·å¾—è¶³å¤Ÿçš„æœºä¼šå°±é¤ã€‚

å°è¯•è§£å†³ä¸Šè¿°å¯èƒ½å­˜åœ¨çš„é—®é¢˜ï¼Œå¹¶ä»‹ç»ä½ çš„è§£å†³æ€è·¯ã€‚

!!! note "å£°æ˜ä¸€ç³»åˆ—çš„ä¿¡å·é‡"

    åœ¨ `pkg/lib/src/sync.rs` ä¸­ï¼Œæä¾›äº† `semaphore_array` å®ï¼Œå¯ä»¥ç”¨äºå¿«é€Ÿå£°æ˜ä¸€ç³»åˆ—ä¿¡å·é‡ï¼š

    ```rust
    static CHOPSTICK: [Semaphore; 5] = semaphore_array![0, 1, 2, 3, 4];
    ```

??? tip "å¯èƒ½çš„è§£å†³æ€è·¯â€¦â€¦"

    åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ï¼Œå¸¸è§çš„è§£å†³æ€è·¯æ˜¯å¼•å…¥ä¸€ä¸ª**â€œæœåŠ¡ç”Ÿâ€**æ¥åè°ƒå“²å­¦å®¶çš„å°±é¤ã€‚

    è¿™ä¸ªæœåŠ¡ç”Ÿä¼š**æ§åˆ¶ç­·å­çš„åˆ†é…**ï¼Œä»è€Œ**é¿å…æ­»é”å’Œé¥¥é¥¿çš„æƒ…å†µ**ã€‚

## æ€è€ƒé¢˜

1. åœ¨ Lab 2 ä¸­è®¾è®¡è¾“å…¥ç¼“å†²åŒºæ—¶ï¼Œå¦‚æœä¸ä½¿ç”¨æ— é”é˜Ÿåˆ—å®ç°ï¼Œè€Œé€‰æ‹©ä½¿ç”¨ `Mutex` å¯¹ä¸€ä¸ªåŒæ­¥é˜Ÿåˆ—è¿›è¡Œä¿æŠ¤ï¼Œåœ¨ç¼–å†™ç›¸å…³å‡½æ•°æ—¶éœ€è¦æ³¨æ„ä»€ä¹ˆé—®é¢˜ï¼Ÿè€ƒè™‘åœ¨è¿›è¡Œ `pop` æ“ä½œè¿‡ç¨‹ä¸­é‡åˆ°ä¸²å£è¾“å…¥ä¸­æ–­çš„æƒ…å½¢ï¼Œå°è¯•æè¿°é‡åˆ°é—®é¢˜çš„åœºæ™¯ï¼Œå¹¶æå‡ºè§£å†³æ–¹æ¡ˆã€‚

2. åœ¨è¿›è¡Œ `fork` çš„å¤åˆ¶å†…å­˜çš„è¿‡ç¨‹ä¸­ï¼Œç³»ç»Ÿçš„å½“å‰é¡µè¡¨ã€è¿›ç¨‹é¡µè¡¨ã€å­è¿›ç¨‹é¡µè¡¨ã€å†…æ ¸é¡µè¡¨ç­‰ä¹‹é—´çš„å…³ç³»æ˜¯æ€æ ·çš„ï¼Ÿåœ¨è¿›è¡Œå†…å­˜å¤åˆ¶æ—¶ï¼Œéœ€è¦æ³¨æ„å“ªäº›é—®é¢˜ï¼Ÿ

3. ä¸ºä»€ä¹ˆåœ¨å®éªŒçš„å®ç°ä¸­ï¼Œ`fork` ç³»ç»Ÿè°ƒç”¨å¿…é¡»åœ¨ä»»ä½• Rust å†…å­˜åˆ†é…ï¼ˆå †å†…å­˜åˆ†é…ï¼‰ä¹‹å‰è¿›è¡Œï¼Ÿå¦‚æœåœ¨å †å†…å­˜åˆ†é…ä¹‹åè¿›è¡Œ `fork`ï¼Œä¼šæœ‰ä»€ä¹ˆé—®é¢˜ï¼Ÿ

4. è¿›è¡ŒåŸå­æ“ä½œæ—¶å€™çš„ `Ordering` å‚æ•°æ˜¯ä»€ä¹ˆï¼Ÿæ­¤å¤„ Rust å£°æ˜çš„å†…å®¹ä¸ [C++20 è§„èŒƒ](https://en.cppreference.com/w/cpp/atomic/memory_order) ä¸­çš„ä¸€è‡´ï¼Œå°è¯•æœç´¢å¹¶ç®€å•äº†è§£ç›¸å…³å†…å®¹ï¼Œç®€å•ä»‹ç»è¯¥æšä¸¾çš„æ¯ä¸ªå€¼å¯¹åº”äºä»€ä¹ˆå«ä¹‰ã€‚

5. åœ¨å®ç° `SpinLock` çš„æ—¶å€™ï¼Œä¸ºä»€ä¹ˆéœ€è¦å®ç° `Sync` traitï¼Ÿç±»ä¼¼çš„ `Send` trait åˆæ˜¯ä»€ä¹ˆå«ä¹‰ï¼Ÿ

6. `core::hint::spin_loop` ä½¿ç”¨çš„ `pause` æŒ‡ä»¤å’Œ Lab 4 ä¸­çš„ `x86_64::instructions::hlt` æŒ‡ä»¤æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿè¿™é‡Œä¸ºä»€ä¹ˆä¸èƒ½ä½¿ç”¨ `hlt` æŒ‡ä»¤ï¼Ÿ

## åŠ åˆ†é¡¹

1.  ğŸ¤” å°è¯•å®ç°å¦‚ä¸‹ç”¨æˆ·ç¨‹åºä»»åŠ¡ï¼Œå®Œæˆç”¨æˆ·ç¨‹åº `fish`ï¼š

    -   åˆ›å»ºä¸‰ä¸ªå­è¿›ç¨‹ï¼Œè®©å®ƒä»¬åˆ†åˆ«èƒ½è¾“å‡ºä¸”åªèƒ½è¾“å‡º `>`ï¼Œ`<` å’Œ `_`ã€‚
    -   ä½¿ç”¨å­¦åˆ°çš„æ–¹æ³•å¯¹è¿™äº›å­è¿›ç¨‹è¿›è¡ŒåŒæ­¥ï¼Œä½¿å¾—æ‰“å°å‡ºçš„åºåˆ—æ€»æ˜¯ `<><_` å’Œ `><>_` çš„ç»„åˆã€‚

    åœ¨å®Œæˆè¿™ä¸€ä»»åŠ¡çš„åŸºç¡€ä¸Šï¼Œå…¶ä»–ç»†èŠ‚å¯ä»¥è‡ªè¡Œå†³å®šå¦‚ä½•å®ç°ï¼ŒåŒ…æ‹¬è¾“å‡ºé•¿åº¦ç­‰ã€‚

2.  ğŸ¤” å°è¯•å’Œå‰æ–‡ä¸åŒçš„å…¶ä»–æ–¹æ³•è§£å†³å“²å­¦å®¶å°±é¤é—®é¢˜ï¼Œå¹¶éªŒè¯ä½ çš„æ–¹æ³•èƒ½å¤Ÿæ­£ç¡®è§£å†³å®ƒï¼Œç®€è¦ä»‹ç»ä½ çš„æ–¹æ³•ï¼Œå¹¶ç»™å‡ºç¨‹åºä»£ç å’Œæµ‹è¯•ç»“æœã€‚

3.  ğŸ”¥ å°è¯•ä½¿ç”¨ç¬¦åˆ Rust åšæ³•çš„æ–¹å¼å¤„ç†äº’æ–¥é”ï¼Œä½¿ç”¨ RAII çš„æ–¹å¼æ¥ä¿è¯é”çš„é‡Šæ”¾ï¼š

    RAIIï¼ˆResource Acquisition Is Initializationï¼‰æ˜¯ä¸€ç§èµ„æºè·å–å³åˆå§‹åŒ–çš„æŠ€æœ¯ï¼Œå®ƒé€šè¿‡åœ¨å¯¹è±¡çš„æ„é€ å‡½æ•°ä¸­è·å–èµ„æºï¼Œç„¶ååœ¨ææ„å‡½æ•°ä¸­é‡Šæ”¾èµ„æºçš„æ–¹æ³•ï¼Œæ¥ä¿è¯èµ„æºçš„æ­£ç¡®é‡Šæ”¾ã€‚

    å¯¹äº Rustï¼Œä¹Ÿå³å®ç° `MutexGuard` ç±»ä¼¼çš„ç»“æ„ï¼Œå®ƒåœ¨æ„é€ æ—¶è·å–é”ï¼Œç„¶ååœ¨æ­¤ç»“æ„ä½“è¢«ç§»å‡ºä½œç”¨åŸŸæ—¶é‡Šæ”¾é”ã€‚

    -   åœ¨ `acquire` æ—¶å€™è¿”å› `MutexGuard` å¯¹è±¡ã€‚
    -   ç§»é™¤ `release` å‡½æ•°ï¼Œä½¿ç”¨ `MutexGuard` çš„ `Drop` trait æ¥é‡Šæ”¾é”ã€‚

    !!! danger "æœ¬é¡¹å®ç°éš¾åº¦è¾ƒå¤§ï¼Œä¸å»ºè®®åˆå­¦è€…å°è¯•ã€‚"

        æœ¬åŠ åˆ†é¡¹æ¶‰åŠåˆ°ç”Ÿå‘½å‘¨æœŸã€unsafe æ„é€ ã€`mem::forget`ã€`Deref` ç­‰å†…å®¹ï¼Œéœ€è¦å¯¹ Rust çš„åº•å±‚å®ç°æœ‰ä¸€å®šçš„äº†è§£ã€‚

    !!! note "ä½œä¸ºæœ¬åŠ åˆ†é¡¹çš„å¤‡é€‰æ–¹æ¡ˆï¼Œå¯ä»¥å°è¯•æŸ¥çœ‹ `spin` crate åŠå…¶ä¾èµ–çš„çš„æºç ï¼Œäº†è§£å…¶å®ç°æ–¹å¼ï¼Œå¹¶è¿›è¡Œä¸€äº›æè¿°ã€è®°å½•å’Œå­¦ä¹ ã€‚"

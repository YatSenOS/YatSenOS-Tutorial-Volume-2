# å®éªŒäº”ï¼šfork çš„å®ç°ã€å¹¶å‘ä¸é”æœºåˆ¶

!!! danger "åœ¨æ‰§è¡Œæ¯ä¸€æ¡å‘½ä»¤å‰ï¼Œè¯·ä½ å¯¹å°†è¦è¿›è¡Œçš„æ“ä½œè¿›è¡Œæ€è€ƒ"

    **ä¸ºäº†ä½ çš„æ•°æ®å®‰å…¨å’Œä¸å¿…è¦çš„éº»çƒ¦ï¼Œè¯·è°¨æ…ä½¿ç”¨ `sudo`ï¼Œå¹¶ç¡®ä¿ä½ äº†è§£æ¯ä¸€æ¡æŒ‡ä»¤çš„å«ä¹‰ã€‚**

    **1. å®éªŒæ–‡æ¡£ç»™å‡ºçš„å‘½ä»¤ä¸éœ€è¦å…¨éƒ¨æ‰§è¡Œ**

    **2. ä¸æ˜¯æ‰€æœ‰çš„å‘½ä»¤éƒ½å¯ä»¥æ— æ¡ä»¶æ‰§è¡Œ**

    **3. ä¸è¦ç›´æ¥å¤åˆ¶ç²˜è´´å‘½ä»¤æ‰§è¡Œ**

## fork çš„å®ç°

åœ¨æ“ä½œç³»ç»Ÿè®¾è®¡ä¸­ï¼Œè¿›ç¨‹çš„æ§åˆ¶é™¤äº†åˆ›å»ºã€ç»ˆæ­¢ç­‰åŸºæœ¬æ“ä½œä¹‹å¤–ï¼Œè¿˜åŒ…æ‹¬äº†è¿›ç¨‹çš„**å¤åˆ¶**ã€‚

è¿™ç§å¤åˆ¶çš„æ“ä½œå¯ä»¥ç”¨äºåˆ›å»º**å­è¿›ç¨‹**ï¼Œè¢«ç§°ä¸º `fork`ï¼Œå®ƒå¯ä»¥ä½¿å¾—ç”¨æˆ·è¿›ç¨‹å…·æœ‰æ§åˆ¶å¤šä¸ªè¿›ç¨‹çš„èƒ½åŠ›ï¼Œä»è€Œå®ç°å¹¶å‘æ‰§è¡Œã€‚

YSOS çš„ `fork` ç³»ç»Ÿè°ƒç”¨è®¾è®¡å¦‚ä¸‹æè¿°ï¼š

!!! note "å‡ºäºå®éªŒè®¾è®¡è€ƒé‡ï¼š<br/>æœ¬å®ç°ä¸ Linux æˆ– [POSIX](https://pubs.opengroup.org/onlinepubs/9699919799/) ä¸­æ‰€å®šä¹‰çš„ `fork` æœ‰æ‰€ä¸åŒï¼Œä¹Ÿç»“åˆäº† Linux ä¸­ `vfork` çš„è¡Œä¸ºã€‚"

- `fork` ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„è¿›ç¨‹ï¼Œæ–°è¿›ç¨‹ç§°ä¸ºå­è¿›ç¨‹ï¼ŒåŸè¿›ç¨‹ç§°ä¸ºçˆ¶è¿›ç¨‹ã€‚
- å­è¿›ç¨‹åœ¨ç³»ç»Ÿè°ƒç”¨åå°†å¾—åˆ° `0` çš„è¿”å›å€¼ï¼Œè€Œçˆ¶è¿›ç¨‹å°†å¾—åˆ°å­è¿›ç¨‹çš„ PIDã€‚å¦‚æœåˆ›å»ºå¤±è´¥ï¼Œçˆ¶è¿›ç¨‹å°†å¾—åˆ° `-1` çš„è¿”å›å€¼ã€‚
- `fork` **ä¸å¤åˆ¶**çˆ¶è¿›ç¨‹çš„å†…å­˜ç©ºé—´ï¼Œ**ä¸å®ç°** Cow (Copy on Write) æœºåˆ¶ï¼Œå³çˆ¶å­è¿›ç¨‹çš„å°†æŒæœ‰ä¸€å®šçš„å…±äº«å†…å­˜ï¼ˆä»£ç æ®µã€æ•°æ®æ®µã€å †ã€bss æ®µç­‰ï¼‰ã€‚
- `fork` å­è¿›ç¨‹ä¸çˆ¶è¿›ç¨‹å…±äº«å†…å­˜ç©ºé—´ï¼ˆé¡µè¡¨ï¼‰ï¼Œä½†**å­è¿›ç¨‹æ‹¥æœ‰è‡ªå·±ç‹¬ç«‹çš„å¯„å­˜å™¨å’Œæ ˆç©ºé—´ã€‚**
- **ç”±äºä¸Šè¿°å†…å­˜åˆ†é…æœºåˆ¶çš„é™åˆ¶ï¼Œ`fork` ç³»ç»Ÿè°ƒç”¨å¿…é¡»åœ¨ä»»ä½• Rust å†…å­˜åˆ†é…ï¼ˆå †å†…å­˜åˆ†é…ï¼‰ä¹‹å‰è¿›è¡Œã€‚**

ä¸ºäº†å®ç°çˆ¶å­è¿›ç¨‹çš„èµ„æºå…±äº«ï¼Œåœ¨å…ˆå‰çš„å®éªŒä¸­ï¼Œå·²ç»åšäº†ä¸€äº›å‡†å¤‡å·¥ä½œï¼š

æ¯”å¦‚ `pkg/kernel/src/proc/paging.rs` ä¸­ï¼Œ`PageTableContext` ä¸­çš„ `Cr3RegValue` è¢« `Arc` ä¿æŠ¤äº†èµ·æ¥ï¼›åœ¨ `pkg/kernel/src/proc/data.rs` ä¸­ï¼Œä¹Ÿå­˜åœ¨ `Arc` åŒ…è£…çš„å…±äº«æ•°æ®çš„å†…å®¹ã€‚

??? note "å¿˜äº† `Arc` æ˜¯ä»€ä¹ˆï¼Ÿ"

    `Arc` æ˜¯ `alloc::sync` ä¸­çš„ä¸€ä¸ªåŸå­å¼•ç”¨è®¡æ•°æ™ºèƒ½æŒ‡é’ˆï¼Œå®ƒå…è®¸å¤šä¸ªçº¿ç¨‹åŒæ—¶æ‹¥æœ‰å¯¹åŒä¸€æ•°æ®çš„æ‰€æœ‰æƒï¼Œä¸”ä¸ä¼šé€ æˆæ•°æ®ç«äº‰ã€‚

    `Arc` çš„ `clone()` æ–¹æ³•ä¼šå¢åŠ å¼•ç”¨è®¡æ•°ï¼Œ`drop()` æ–¹æ³•ä¼šå‡å°‘å¼•ç”¨è®¡æ•°ï¼Œå½“å¼•ç”¨è®¡æ•°ä¸º 0 æ—¶ï¼Œæ•°æ®ä¼šè¢«é‡Šæ”¾ã€‚`Arc` æœ¬èº«æ˜¯**ä¸å¯å˜çš„**ï¼Œä½†å¯ä»¥é€šè¿‡ `RwLock` è·å–å†…éƒ¨å¯å˜æ€§ï¼Œè¿›è€Œå®‰å…¨çš„ä¿®æ”¹ä¸€ä¸ªè¢«å¤šä¸ªçº¿ç¨‹æ‰€æŒæœ‰çš„æ•°æ®ã€‚

å¯¹äº Windows ç­‰å°†è¿›ç¨‹æŠ½è±¡ä¸ºèµ„æºå®¹å™¨çš„æ“ä½œç³»ç»Ÿï¼Œè¿™äº›éœ€è¦å…±äº«çš„èµ„æºä¹Ÿå°±ä¼šè¢«æŠ½è±¡ä¸º**è¿›ç¨‹å¯¹è±¡**ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå®éªŒæ‰€è®¾è®¡çš„è¡Œä¸ºåˆæ›´ç±»ä¼¼äº â€œæ–°å»ºä¸€ä¸ªæ‰§è¡Œçº¿ç¨‹â€ çš„æ“ä½œã€‚

### ç³»ç»Ÿè°ƒç”¨

æœ‰äº†ä¸Šä¸€æ¬¡å®éªŒçš„ç»éªŒï¼Œç³»ç»Ÿè°ƒç”¨çš„æ–°å¢ã€å¤„ç†å‡å·²ç»æœ‰äº†ä¸€å®šçš„ç»éªŒï¼Œæ­¤å¤„ä¸è¿‡å¤šèµ˜è¿°ã€‚å¯¹ `fork` ç³»ç»Ÿè°ƒç”¨æœ‰å¦‚ä¸‹çº¦å®šï¼Œåˆ«å¿˜äº†åœ¨ `syscall_def` ä¸­å®šä¹‰ä½ çš„ç³»ç»Ÿè°ƒç”¨å·ï¼š

```rust
// None -> pid: u16 or 0 or -1
Syscall::Fork => { /* ... */},
```

!!! tip "å¦‚æœä½ å’Œç¬”è€…ä¸€æ ·æœ‰å¼ºè¿«ç—‡ï¼ŒLinux ç›¸å…³åŠŸèƒ½çš„ç³»ç»Ÿè°ƒç”¨å·æ˜¯ `58`"

### è¿›ç¨‹ç®¡ç†

!!! warning "å…³äºå…·ä½“çš„å®ç°"

    å®éªŒè‡³æ­¤ï¼Œä½ ä¹Ÿåº”å½“ç§¯ç´¯äº†ä¸€äº›è‡ªå·±çš„é¡¹ç›®ç®¡ç†ç»éªŒï¼Œå¯¹äºä¸Šè¿°çš„ `FIXME`ï¼Œä½ åº”å½“æœ‰ä¸€äº›è‡ªå·±çš„æƒ³æ³•ï¼Œç”¨åˆé€‚çš„æ–¹å¼è¿›è¡Œå®ç°ã€‚

    åç»­çš„å®Œå–„å°†ä¼šç»™å‡ºä¸€äº›æç¤ºã€å»ºè®®å’Œæ³¨æ„äº‹é¡¹ï¼Œç›¸å…³ä»£ç ç»“æ„å¹¶ä¸éœ€è¦**å®Œå…¨æŒ‰ç…§æ–‡æ¡£è¿›è¡Œ**ã€‚

    **è¯·æ³¨æ„ï¼šæ¯ä¸ª `FIXME` å¹¶ä¸ä»£è¡¨æ­¤åŠŸèƒ½å¿…é¡»åœ¨å¯¹åº”çš„ä½ç½®å®ç°ï¼Œä½ ä¹Ÿåº”å½“è‡ªç”±ç®¡ç†ç›¸å…³å‡½æ•°çš„è¿”å›å€¼ã€å‚æ•°ç­‰ã€‚**

åœ¨å¤„ç†å¥½ç”¨æˆ·æ€åº“å’Œç³»ç»Ÿè°ƒç”¨çš„å¯¹æ¥åï¼Œå‚è€ƒå¦‚ä¸‹ä»£ç ï¼Œå®Œå–„ä½ çš„ `fork`:

!!! note "å¾€ä¸‹ç¿»ç¿»ï¼Œè¯´æ˜æ›´å¤šå“¦ï¼ˆä¸ºä»€ä¹ˆæ€»æœ‰äººä¸çœ‹å®Œæ–‡æ¡£å°±å¼€å§‹å†™ä»£ç ï¼ï¼‰"

```rust
pub fn fork(context: &mut ProcessContext) {
    x86_64::instructions::interrupts::without_interrupts(|| {
        let manager = get_process_manager();
        // FIXME: save_current as parent
        // FIXME: fork to get child
        // FIXME: push to child & parent to ready queue
        // FIXME: switch to next process
    })
}
// ...
impl ProcessManager {
    pub fn fork(&self) {
        // FIXME: get current process
        // FIXME: fork to get child
        // FIXME: add child to process list

        // FOR DBG: maybe print the process ready queue?
    }
}
// ...
pub struct ProcessInner {
    // ...
    parent: Option<Weak<Process>>,
    children: Vec<Arc<Process>>,
    // ...
}
// ...
impl Process {
    pub fn fork(self: &Arc<Self>) -> Arc<Self> {
        // FIXME: lock inner as write
        // FIXME: inner fork with parent weak ref

        // FOR DBG: maybe print the child process info (parent, name, pid, etc.)

        // FIXME: make the arc of child
        // FIXME: add child to current process's children list
        // FIXME: mark the child as ready & return it
    }
}
// ...
impl ProcessInner {
    pub fn fork(&mut self, parent: Weak<Process>) -> ProcessInner {
        // FIXME: get current process's stack info

        // FIXME: clone the process data struct
        // FIXME: clone the page table context (see instructions)

        // FIXME: alloc & map new stack for child (see instructions)
        // FIXME: copy the *entire stack* from parent to child

        // FIXME: update child's stack frame with new *stack pointer*
        //          > keep lower bits of rsp, set the higher bits to the new base
        //          > also update the stack record in process data
        // FIXME: set the return value 0 for child with `context.set_rax`

        // FIXME: construct the child process inner

        // NOTE: return inner because there's no pid record in inner
    }
}
```

å…³äºå…·ä½“çš„ä»£ç å®ç°ï¼Œå‚è€ƒå¦‚ä¸‹çš„æç¤ºå’Œè¯´æ˜ï¼š

1. å°†åŠŸèƒ½çš„å…·ä½“å®ç°å§”æ‰˜è‡³ä¸‹ä¸€çº§è¿›è¡Œï¼Œä¿æŒä»£ç è¯­ä¹‰çš„ç®€æ´ã€‚

    - ç³»ç»Ÿè°ƒç”¨é™æ€å‡½æ•°ï¼Œå¹¶å°†å…¶å§”æ‰˜ç»™ `ProcessManager::fork`ã€‚
    - `ProcessManager::fork` å°†å…·ä½“å®ç°å§”æ‰˜ç»™å½“å‰è¿›ç¨‹çš„ `Process::fork`ã€‚
    - `Process::fork` å°†å…·ä½“å®ç°å§”æ‰˜ç»™ `ProcessInner::fork`ã€‚

    æ¯ä¸€å±‚ä»£ç åªå…³å¿ƒè‡ªå·±å±‚çº§çš„é€»è¾‘å’Œæ•°æ®ï¼Œä¸å…³å¿ƒæŒæœ‰è‡ªèº«çš„é”æˆ–å…¶ä»–å¤–éƒ¨æ•°æ®çš„çŠ¶æ€ï¼Œè¿›è€Œæé«˜ä»£ç å¯ç»´æŠ¤æ€§ã€‚

2. ä½¿ç”¨å…ˆå‰å®ç°çš„ `save_current` å’Œ `switch_next` ç­‰å‡½æ•°ï¼Œæé«˜ä»£ç å¤ç”¨æ€§ã€‚

    å¦‚æœä½¿ç”¨æ—¶é‡åˆ°äº†é—®é¢˜ï¼Œå¾ˆå¯èƒ½æ˜¯ä½ çš„ä»£ç è¿‡äºç›¸äº’è€¦åˆï¼Œå°è¯•å°†é€»è¾‘è¿›è¡Œåˆ†ç¦»ï¼Œä¿è¯å‡½æ•°åŠŸèƒ½çš„å•ä¸€æ€§ã€‚

3. åˆ©ç”¨å¥½å‡½æ•°çš„è¿”å›å€¼ç­‰æœºåˆ¶ï¼Œæ³¨æ„ç›¸å…³æ“ä½œçš„æ‰§è¡Œé¡ºåºã€‚

4. ä½¿ç”¨ `Arc::downgrade` è·å– `Weak` å¼•ç”¨ï¼Œä»è€Œé¿å…å¾ªç¯å¼•ç”¨ã€‚

    çˆ¶è¿›ç¨‹æŒæœ‰å­è¿›ç¨‹çš„å¼ºå¼•ç”¨ï¼Œå­è¿›ç¨‹æŒæœ‰çˆ¶è¿›ç¨‹çš„å¼±å¼•ç”¨ï¼Œè¿™æ ·å¯ä»¥é¿å…å¾ªç¯å¼•ç”¨å¯¼è‡´çš„å†…å­˜æ³„æ¼ã€‚

5. ä¸ºäº†å¤åˆ¶æ ˆç©ºé—´ï¼Œä½ å¯ä»¥ä½¿ç”¨ `core::intrinsics::copy_nonoverlapping` å‡½æ•°ã€‚

    è¿™ä¸ªå‡½æ•°ä¼šä½¿ç”¨åº•å±‚ LLVM æ‰€æä¾›çš„å†…å­˜å¤åˆ¶ç›¸å…³æŒ‡ä»¤ï¼Œå…·æœ‰è¾ƒé«˜çš„æ€§èƒ½ã€‚éœ€è¦è°ƒç”¨ä¾§ä¿è¯æºå’Œç›®æ ‡çš„å†…å­˜ç©ºé—´ä¸ä¼šé‡å ã€‚å¯ä»¥å°è£…ä¸ºå¦‚ä¸‹å‡½æ•°è¿›è¡Œä½¿ç”¨ï¼š

    ```rust
    /// Clone a range of memory
    ///
    /// - `src_addr`: the address of the source memory
    /// - `dest_addr`: the address of the target memory
    /// - `size`: the count of pages to be cloned
    fn clone_range(src_addr: u64, dest_addr: u64, size: usize) {
        trace!("Clone range: {:#x} -> {:#x}", src_addr, dest_addr);
        unsafe {
            copy_nonoverlapping::<u8>(
                src_addr as *mut u8,
                dest_addr as *mut u8,
                size * Size4KiB::SIZE as usize,
            );
        }
    }
    ```

6. ä¸ Lab 3 ä¸­çš„å¤šå†…æ ¸çº¿ç¨‹çš„æ ˆåˆ†é…ç±»ä¼¼ï¼Œä¸ºå­è¿›ç¨‹åˆ†é…æ ˆç©ºé—´ã€‚

    ä¸ Lab 3 ä¸­ä½¿ç”¨ PID æ¥è®¡ç®—æ ˆçš„åŸºå€ä¸åŒï¼Œæ­¤å¤„ä½¿ç”¨é¡µè¡¨çš„è¢«å¼•ç”¨æ•°é‡ `strong_count` æ¥è®¡ç®—æ ˆçš„åŸºå€ã€‚

    ä¸ºæ­¤ï¼Œä½ éœ€è¦è¡¥å……ä¸€äº›ç›¸å…³çš„å‡½æ•°è°ƒç”¨ï¼š

    ```rust
    impl PageTableContext {
        // ...
        pub fn using_count(&self) -> usize {
            Arc::strong_count(&self.reg)
        }

        pub fn fork(&self) -> Self {
            // forked process shares the page table
            Self {
                reg: self.reg.clone(),
            }
        }
        // ...
    }
    ```

    ä¹Ÿå¯ä»¥è¡¥å……ä¸€äº›ç›¸å…³çš„è°ƒè¯•ä¿¡æ¯ï¼š

    ```rust
    impl core::fmt::Debug for PageTableContext {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            // ...
                .field("refs", &self.using_count())
            // ...
        }
    }
    ```

    æœ€ç»ˆï¼Œé¢„æœŸçš„æ ˆç©ºé—´åˆ†å¸ƒå¦‚ä¸‹ï¼š

    ```txt
    +---------------------------------+ <- 0x400000000000
    |     PageTable 1st Ref Stack     |
    +---------------------------------+ <- 0x3FFF00000000
    |     PageTable 2nd Ref Stack     |
    +---------------------------------+ <- 0x3FFE00000000
    |     PageTable 3rd Ref Stack     |
    +---------------------------------+ <- 0x3FFD00000000
    |               ...               |
    +---------------------------------+
    ```

### åŠŸèƒ½æµ‹è¯•

åœ¨å®Œæˆäº† `fork` çš„å®ç°åï¼Œä½ éœ€è¦é€šè¿‡å¦‚ä¸‹åŠŸèƒ½æµ‹è¯•æ¥éªŒè¯ä½ çš„å®ç°æ˜¯å¦æ­£ç¡®ï¼š

```rust
#![no_std]
#![no_main]

extern crate alloc;
extern crate lib;

use lib::*;

static mut M: u64 = 0xdeadbeef;

fn main() -> usize {
    let mut c = 32;

    let pid = sys_fork();

    if pid == 0 {
        println!("I am the child process");

        assert_eq!(c, 32);

        unsafe {
            println!("child read value of M: {:#x}", M);
            M = 0x2333;
            println!("child changed the value of M: {:#x}", M);
        }

        c += 32;
    } else {
        println!("I am the parent process");

        sys_stat();

        assert_eq!(c, 32);

        println!("Waiting for child to exit...");

        let ret = sys_wait_pid(pid);

        println!("Child exited with status {}", ret);

        assert_eq!(ret, 64);

        unsafe {
            println!("parent read value of M: {:#x}", M);
            assert_eq!(M, 0x2333);
        }

        c += 1024;

        assert_eq!(c, 1056);
    }

    c
}

entry!(main);
```

## å¹¶å‘ä¸é”æœºåˆ¶

ç”±äºå¹¶å‘æ‰§è¡Œæ—¶ï¼Œçº¿ç¨‹çš„è°ƒåº¦é¡ºåºæ— æ³•é¢„çŸ¥ï¼Œè¿›è€Œé€ æˆçš„æ‰§è¡Œé¡ºåºä¸ç¡®å®šï¼Œ**æŒæœ‰å…±äº«èµ„æºçš„è¿›ç¨‹ä¹‹é—´çš„å¹¶å‘æ‰§è¡Œå¯èƒ½ä¼šå¯¼è‡´æ•°æ®çš„ä¸ä¸€è‡´**ï¼Œæœ€ç»ˆå¯¼è‡´ç›¸åŒçš„ç¨‹åºäº§ç”Ÿä¸€ç³»åˆ—ä¸åŒçš„ç»“æœï¼Œè¿™æ ·çš„æƒ…å†µè¢«ç§°ä¹‹ä¸º**ç«æ€æ¡ä»¶ï¼ˆrace conditionï¼‰**ã€‚

!!! tip "æ¡ä»¶ç«äº‰â€¦â€¦ï¼Ÿ"

    æ¶æ„ç¨‹åºåˆ©ç”¨ç±»ä¼¼çš„åŸç†ï¼Œé€šè¿‡ä¸æ–­åœ°å°è¯•ï¼Œæœ€ç»ˆç»•è¿‡æ£€æŸ¥ï¼Œè·å¾—äº†ä¸€äº›ä¸åº”è¯¥è¢«è®¿é—®çš„èµ„æºï¼Œè¿™ç§å¯¹ç³»ç»Ÿçš„æ”»å‡»è¡Œä¸ºä¹Ÿè¢«ç§°ä¸ºæ¡ä»¶ç«äº‰ã€‚

    > å®ƒä»¬çš„è‹±æ–‡ç¿»è¯‘éƒ½æ˜¯ Race Conditionï¼Œä½†åœ¨ä¸åŒçš„é¢†åŸŸå†…å¸¸ç”¨ä¸åŒçš„ç¿»è¯‘ã€‚

    ä¸€ä¸ªè‘—åçš„ä¾‹å­æ˜¯ Linux å†…æ ¸æƒé™æå‡æ¼æ´ Dirty COW (CVE-2016-5195)ï¼Œé€šè¿‡æ¡ä»¶ç«äº‰ä½¿å¾—æ™®é€šç”¨æˆ·å¯ä»¥å†™å…¥åŸæœ¬åªè¯»çš„å†…å­˜åŒºåŸŸï¼Œä»è€Œæå‡æƒé™ã€‚

è€ƒè™‘å¦‚ä¸‹çš„ä»£ç ï¼š

```rust
static mut COUNTER: usize = 0;

fn main() {
    let mut handles = vec![];

    for _ in 0..10 {
        handles.push(std::thread::spawn(|| {
            for _ in 0..1000 {
                unsafe {
                    COUNTER += 1;
                }
            }
        }));
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", unsafe { COUNTER });
}
```

!!! tip "å¯ä»¥ç›´æ¥ä½¿ç”¨ `rustc main.rs` è¿›è¡Œç¼–è¯‘"

å¾—åˆ°çš„ç»“æœå¦‚ä¸‹ï¼š

```bash
$ for ((i = 0; i < 16; i++)); do ./main; done
Result: 9595
Result: 8838
Result: 8315
Result: 7602
Result: 9120
Result: 8485
Result: 8831
Result: 8717
Result: 8812
Result: 8955
Result: 9266
Result: 8168
Result: 9159
Result: 10000
Result: 9664
Result: 10000
```

å¯ä»¥çœ‹åˆ°ï¼Œæ¯æ¬¡è¿è¡Œçš„ç»“æœéƒ½å¯èƒ½ä¸ä¸€æ ·ï¼Œè¿™æ˜¯å› ä¸º `COUNTER += 1` æ“ä½œå¹¶ä¸æ˜¯åŸå­çš„ï¼Œå®ƒåŒ…å«äº†è¯»å–ã€ä¿®æ”¹å’Œå†™å…¥ä¸‰ä¸ªæ­¥éª¤ï¼Œè€Œåœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹ï¼Œè¿™ä¸‰ä¸ªæ­¥éª¤ä¹‹é—´å¯èƒ½ä¼šè¢«å…¶ä»–çº¿ç¨‹ï¼ˆé€šè¿‡æ“ä½œç³»ç»Ÿçš„æ—¶é’Ÿä¸­æ–­æˆ–å…¶ä»–æ–¹å¼ï¼‰æ‰“æ–­ï¼Œåæ±‡ç¼–ä¸Šè¿°ä»£ç ï¼Œå¯ä»¥çœ‹åˆ° `COUNTER += 1` çš„å®é™…æ“ä½œï¼š

```nasm
mov rax, qword [obj.main::COUNTER::hfb966cd5c23908b7] # read COUNTER to rax
add rax, 1                                            # rax += 1
# ... overflow check by rustc ...
mov qword [obj.main::COUNTER::hfb966cd5c23908b7], rax # write rax to COUNTER
```

è€ƒè™‘å¦‚ä¸‹çš„æ‰§è¡Œé¡ºåºï¼ˆå®é™…æ‰§è¡Œçš„æ—¶é’Ÿä¸­æ–­ä¼šæ…¢å¾—å¤šï¼Œæ‰€ä»¥ä¸Šè¿°ä»£ç ä½¿ç”¨å¾ªç¯æ¥å‡¸æ˜¾è¿™ä¸€é—®é¢˜ï¼‰ï¼š

```nasm
# Thread 1
mov rax, qword [obj.main::COUNTER::hfb966cd5c23908b7]
add rax, 1

# !!! Context Switch !!!

# Thread 2
mov rax, qword [obj.main::COUNTER::hfb966cd5c23908b7]

# !!! Context Switch !!!

# Thread 1
mov qword [obj.main::COUNTER::hfb966cd5c23908b7], rax

# !!! Context Switch !!!

# Thread 2
add rax, 1
mov qword [obj.main::COUNTER::hfb966cd5c23908b7], rax
```

åœ¨è¿™æ ·çš„æ‰§è¡Œé¡ºåºä¸‹ï¼Œ`COUNTER` çš„å€¼ä¼šæ¯”é¢„æœŸå°‘ï¼Œå‡ ä¸ªçº¿ç¨‹å¯èƒ½ä¼šåŒæ—¶è¯»å–åˆ°ç›¸åŒçš„å€¼ï¼Œç„¶ååŒæ—¶å†™å…¥ç›¸åŒçš„å€¼ï¼Œè¿™æ ·çš„è¡Œä¸ºå°±ä¼šå¯¼è‡´ `+=` çš„è¯­æ„è¢«ç ´åã€‚

ä¸Šé¢è¿™ç§è®¿é—®å…±äº«èµ„æºçš„ä»£ç ç‰‡æ®µè¢«ç§°ä¸º**ä¸´ç•ŒåŒº**ï¼Œä¸ºäº†ä¿è¯ä¸´ç•ŒåŒºçš„æ­£ç¡®æ€§ï¼Œéœ€è¦ç¡®ä¿**æ¯æ¬¡åªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥è¿›å…¥ä¸´ç•ŒåŒº**ï¼Œä¹Ÿå³ä¿è¯è¿™éƒ¨åˆ†æŒ‡ä»¤åºåˆ—æ˜¯**äº’æ–¥**çš„ã€‚

### åŸå­æŒ‡ä»¤

ä¸€èˆ¬è€Œè¨€ï¼Œä¸ºäº†è§£å†³å¹¶å‘ä»»åŠ¡å¸¦æ¥çš„é—®é¢˜ï¼Œéœ€è¦é€šè¿‡æŒ‡ä»¤é›†ä¸­çš„åŸå­æ“ä½œæ¥ä¿è¯æ•°æ®çš„ä¸€è‡´æ€§ã€‚åœ¨ Rust ä¸­ï¼Œè¿™ç±»åŸå­æŒ‡ä»¤è¢«å°è£…åœ¨ `core::sync::atomic` æ¨¡å—ä¸­ï¼Œä½œä¸ºæ¶æ„æ— å…³çš„åŸå­æ“ä½œæ¥æä¾›å¹¶å‘å®‰å…¨æ€§ã€‚

ä»¥ `AtomicUsize` ä¸ºä¾‹ï¼Œå®ƒæä¾›äº†ä¸€ç³»åˆ—çš„åŸå­æ“ä½œï¼Œå¦‚ `fetch_add`ã€`fetch_update`ã€`compare_exchange` ç­‰ï¼Œè¿™äº›æ“ä½œéƒ½æ˜¯åŸå­çš„ï¼Œä¸ä¼šè¢«å…¶ä»–çº¿ç¨‹æ‰“æ–­ï¼Œå¯¹äºä¹‹å‰çš„ä¾‹å­ï¼š

```rust
static COUNTER: AtomicUsize = AtomicUsize::new(0);
COUNTER.fetch_add(1, Ordering::SeqCst);
```

å…¶ä¸­ `Ordering` ç”¨æˆ·æ§åˆ¶å†…å­˜é¡ºåºï¼Œåœ¨å•æ ¸æƒ…å†µä¸‹ï¼Œ`Ordering` çš„é€‰æ‹©å¹¶ä¸ä¼šå½±å“ç¨‹åºçš„è¡Œä¸ºï¼Œå¯ä»¥ç®€å•äº†è§£ï¼Œå¹¶å°è¯•å›ç­”æ€è€ƒé¢˜ 4 çš„å†…å®¹ã€‚

åœ¨ç¼–è¯‘å™¨ä¼˜åŒ–åå°†ä¼šè¢«ç¼–è¯‘ä¸ºï¼š

```nasm
lock inc qword [obj.main::COUNTER::h2889e4585a2a2d30]
```

è¿™å°±æ˜¯ä¸€å¥åŸå­çš„ `inc` æŒ‡ä»¤ï¼Œä¸­æ–­æˆ–ä»»åŠ¡åˆ‡æ¢éƒ½ä¸ä¼šæ‰“æ–­è¿™ä¸ªæŒ‡ä»¤çš„æ‰§è¡Œï¼Œä»è€Œä¿è¯äº† `COUNTER` çš„ä¸€è‡´æ€§ã€‚

åœ¨äº†è§£äº†åŸå­æŒ‡ä»¤çš„åŸºæœ¬æ¦‚å¿µåï¼Œå¯ä»¥åˆ©ç”¨å®ƒæ¥ä¸ºç”¨æˆ·æ€ç¨‹åºæä¾›ä¸¤ç§ç®€å•çš„åŒæ­¥æ“ä½œï¼šè‡ªæ—‹é” `SpinLock` å’Œä¿¡å·é‡ `Semaphore`ã€‚å…¶ä¸­è‡ªæ—‹é”çš„å®ç°å¹¶ä¸éœ€è¦å†…æ ¸æ€çš„æ”¯æŒï¼Œè€Œä¿¡å·é‡åˆ™ä¼šæ¶‰åŠåˆ°è¿›ç¨‹è°ƒåº¦ç­‰æ“ä½œï¼Œéœ€è¦å†…æ ¸æ€çš„æ”¯æŒã€‚

æ­£å› å¦‚æ­¤ï¼Œåœ¨è¿›è¡Œå†…æ ¸ç¼–å†™çš„è¿‡ç¨‹ä¸­é‡åˆ°çš„ `Mutex` å’Œ `RwLock` ç­‰ç”¨äºä¿éšœå†…æ ¸æ€æ•°æ®ä¸€è‡´æ€§çš„é”æœºåˆ¶**å‡æ˜¯åŸºäºè‡ªæ—‹é”å®ç°çš„**ï¼Œ_ä½ å¯èƒ½åœ¨ä¹‹å‰çš„å®éªŒä¸­é‡åˆ°è¿‡ç³»ç»Ÿå› ä¸ºè‡ªæ—‹å¿™ç­‰å¾…å¯¼è‡´çš„å¼‚å¸¸æƒ…å†µ_ã€‚

#### è‡ªæ—‹é”

è‡ªæ—‹é” `SpinLock` æ˜¯ä¸€ç§ç®€å•çš„é”æœºåˆ¶ï¼Œå®ƒé€šè¿‡ä¸æ–­åœ°æ£€æŸ¥é”çš„çŠ¶æ€æ¥å®ç°çº¿ç¨‹çš„é˜»å¡ï¼Œç›´åˆ°è·å–åˆ°é”ä¸ºæ­¢ã€‚

åœ¨ `pkg/lib/src/sync.rs` ä¸­ï¼Œå…³æ³¨ `SpinLock` çš„å®ç°ï¼š

```rust
pub struct SpinLock {
    bolt: AtomicBool,
}

impl SpinLock {
    pub const fn new() -> Self {
        Self {
            bolt: AtomicBool::new(false),
        }
    }

    pub fn acquire(&mut self) {
        // FIXME: acquire the lock, spin if the lock is not available
    }

    pub fn release(&mut self) {
        // FIXME: release the lock
    }
}

// Why? Check reflection question 5
unsafe impl Sync for SpinLock {}
```

åœ¨å®ç° `acquire` å’Œ `release` æ—¶ï¼Œä½ éœ€è¦ä½¿ç”¨ `AtomicBool` çš„åŸå­æ“ä½œæ¥ä¿è¯é”çš„æ­£ç¡®æ€§ï¼š

- `load` å‡½æ•°ç”¨äºè¯»å–å½“å‰å€¼ã€‚
- `store` å‡½æ•°ç”¨äºè®¾ç½®æ–°å€¼ã€‚
- `compare_exchange` å‡½æ•°ç”¨æˆ·åŸå­å¾—è¿›è¡Œæ¯”è¾ƒ-äº¤æ¢ï¼Œä¹Ÿå³æ¯”è¾ƒå½“å‰å€¼æ˜¯å¦ä¸ºç›®æ ‡å€¼ï¼Œå¦‚æœæ˜¯åˆ™å°†å…¶è®¾ç½®ä¸ºæ–°å€¼ï¼Œå¦åˆ™è¿”å›å½“å‰å€¼ã€‚

åœ¨è¿›è¡Œå¾ªç¯ç­‰å¾…æ—¶ï¼Œå¯ä»¥ä½¿ç”¨ `core::hint::spin_loop` æé«˜æ€§èƒ½ï¼Œåœ¨ x86_64 æ¶æ„ä¸­ï¼Œå®ƒå®é™…ä¸Šä¼šç¼–è¯‘ä¸º `pause` æŒ‡ä»¤ã€‚

#### ä¿¡å·é‡

å¾—åˆ©äº Rust è‰¯å¥½çš„åº•å±‚å°è£…ï¼Œè‡ªæ—‹é”çš„å®ç°éå¸¸ç®€å•ã€‚ä½†æ˜¯ä¹Ÿå­˜åœ¨ä¸€å®šçš„é—®é¢˜ï¼š

- å¿™ç­‰å¾…ï¼šè‡ªæ—‹é”ä¼šä¸€ç›´å ç”¨ CPU æ—¶é—´ï¼Œç›´åˆ°è·å–åˆ°é”ä¸ºæ­¢ï¼Œè¿™ä¼šå¯¼è‡´ CPU åˆ©ç”¨ç‡çš„ä¸‹é™ã€‚
- é¥¥é¥¿ï¼šå¦‚æœä¸€ä¸ªçº¿ç¨‹ä¸€ç›´å ç”¨é”ï¼Œå…¶ä»–çº¿ç¨‹å¯èƒ½ä¼šä¸€ç›´æ— æ³•è·å–åˆ°é”ã€‚
- æ­»é”ï¼šå¦‚æœä¸¤ä¸ªçº¿ç¨‹äº’ç›¸ç­‰å¾…å¯¹æ–¹å æœ‰çš„é”ï¼Œå°±ä¼šå¯¼è‡´æ­»é”ã€‚

ä¿¡å·é‡ `Semaphore` æ˜¯ä¸€ç§æ›´ä¸ºå¤æ‚çš„åŒæ­¥æœºåˆ¶ï¼Œå®ƒå¯ä»¥ç”¨äºæ§åˆ¶å¯¹å…±äº«èµ„æºçš„è®¿é—®ï¼Œä¹Ÿå¯ä»¥ç”¨äºæ§åˆ¶å¯¹ä¸´ç•ŒåŒºçš„è®¿é—®ã€‚é€šè¿‡ä¸è¿›ç¨‹è°ƒåº¦ç›¸å…³çš„æ“ä½œï¼Œä¿¡å·é‡è¿˜å¯ä»¥ç”¨äºæ§åˆ¶è¿›ç¨‹çš„æ‰§è¡Œé¡ºåºã€æé«˜ CPU åˆ©ç”¨ç‡ç­‰ã€‚

ä¿¡å·é‡éœ€è¦å®ç°å››ç§æ“ä½œï¼š

- `new`ï¼šæ ¹æ®æ‰€ç»™å‡ºçš„ `key` åˆ›å»ºä¸€ä¸ªæ–°çš„ä¿¡å·é‡ã€‚
- `remove`ï¼šæ ¹æ®æ‰€ç»™å‡ºçš„ `key` åˆ é™¤ä¸€ä¸ªå·²ç»å­˜åœ¨çš„ä¿¡å·é‡ã€‚
- `siganl`ï¼šä¹Ÿå«åš `V` æ“ä½œï¼Œä¹Ÿå¯ä»¥è¢« `release/up/verhogen` è¡¨ç¤ºï¼Œå®ƒç”¨äºé‡Šæ”¾ä¸€ä¸ªèµ„æºï¼Œä½¿å¾—ç­‰å¾…çš„è¿›ç¨‹å¯ä»¥ç»§ç»­æ‰§è¡Œã€‚
- `wait`ï¼šä¹Ÿå«åš `P` æ“ä½œï¼Œä¹Ÿå¯ä»¥è¢« `acquire/down/proberen` è¡¨ç¤ºï¼Œå®ƒç”¨äºè·å–ä¸€ä¸ªèµ„æºï¼Œå¦‚æœèµ„æºä¸å¯ç”¨ï¼Œåˆ™è¿›ç¨‹å°†ä¼šè¢«é˜»å¡ã€‚

ä¸ºäº†å®ç°ä¸å†…æ ¸çš„äº¤äº’ï¼Œä¿¡å·é‡çš„æ“ä½œå°†è¢«å®ç°ä¸ºä¸€ä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œå®ƒå°†ä½¿ç”¨åˆ°ä¸‰ä¸ªç³»ç»Ÿè°ƒç”¨å‚æ•°ï¼š

```rust
// op: u8, key: u32, val: usize -> ret: any
Syscall::Sem => sys_sem(&args, context),
```

å…¶ä¸­ `op` ä¸ºæ“ä½œç ï¼Œ`key` ä¸ºä¿¡å·é‡çš„é”®å€¼ï¼Œ`val` ä¸ºä¿¡å·é‡çš„å€¼ï¼Œ`ret` ä¸ºè¿”å›å€¼ã€‚æ ¹æ®å…ˆå‰çš„çº¦å®šï¼Œ`op` è¢«æ”¾ç½®åœ¨ `rdi` å¯„å­˜å™¨ä¸­ï¼Œ`key` å’Œ `val` åˆ†åˆ«è¢«æ”¾ç½®åœ¨ `rsi` å’Œ `rdx` å¯„å­˜å™¨ä¸­ï¼Œå¯ä»¥é€šè¿‡ `args.arg0`ã€`args.arg1` å’Œ `args.arg2` æ¥è¿›è¡Œè®¿é—®ã€‚

ä¿¡å·é‡ç›¸å…³å†…å®¹åœ¨ `pkg/kernel/src/proc/sync.rs` ä¸­è¿›è¡Œå®ç°ï¼š

â€œèµ„æºâ€ è¢«æŠ½è±¡ä¸ºä¸€ä¸ª `usize` æ•´æ•°ï¼Œå®ƒ**å¹¶ä¸éœ€è¦ä½¿ç”¨ `AtomicUsize`**ï¼Œä¸ºäº†å­˜å‚¨ç­‰å¾…çš„è¿›ç¨‹ï¼Œéœ€è¦åœ¨æ­¤æ•´æ•°å¤–é¢å¤–ä½¿ç”¨ä¸€ä¸ª `Vec` æ¥å­˜å‚¨ç­‰å¾…çš„è¿›ç¨‹ã€‚å®ƒä»¬äºŒè€…å°†ä¼šè¢«ä¸€ä¸ªè‡ªæ—‹é”å®ç°çš„äº’æ–¥é”ï¼ˆåœ¨å†…æ ¸ä¸­ç›´æ¥ä½¿ç”¨ `spin::Mutex`ï¼‰ä¿æŠ¤ã€‚

```rust
pub struct Semaphore {
    count: usize,
    wait_queue: Vec<ProcessId>,
}
```

ä¿¡å·é‡æ“ä½œçš„ç»“æœä½¿ç”¨ `SemaphoreResult` è¡¨ç¤ºï¼š

```rust
pub enum SemaphoreResult {
    Ok,
    NotExist,
    Block(ProcessId),
    WakeUp(ProcessId),
}
```

- `Ok`ï¼šè¡¨ç¤ºæ“ä½œæˆåŠŸï¼Œä¸”æ— éœ€è¿›è¡Œé˜»å¡æˆ–å”¤é†’ã€‚
- `NotExist`ï¼šè¡¨ç¤ºä¿¡å·é‡ä¸å­˜åœ¨ã€‚
- `Block(ProcessId)`ï¼šè¡¨ç¤ºæ“ä½œéœ€è¦é˜»å¡çº¿ç¨‹ï¼Œä¸€èˆ¬æ˜¯å½“å‰è¿›ç¨‹ã€‚
- `WakeUp(ProcessId)`ï¼šè¡¨ç¤ºæ“ä½œéœ€è¦å”¤é†’çº¿ç¨‹ã€‚

ä¸ºäº†å®ç°ä¿¡å·é‡çš„ KV å­˜å‚¨ï¼Œä½¿ç”¨ `SemaphoreSet` å®šä¹‰ä¿¡å·é‡é›†åˆçš„æ“ä½œï¼š

```rust
pub struct SemaphoreSet {
    sems: BTreeMap<SemaphoreId, Mutex<Semaphore>>,
}
```

å¹¶åœ¨ `ProcessData` ä¸­æ·»åŠ ä¸ºçº¿ç¨‹å…±äº«èµ„æºï¼š

```rust
pub struct ProcessData {
    // ...
    pub(super) semaphores: Arc<RwLock<SemaphoreSet>>,
    // ...
}
```

!!! note "å…³äºè¿™é‡Œçš„ä¸€å †é”â€¦â€¦"

    åœ¨æœ¬å®éªŒå®ç°çš„å•æ ¸å¤„ç†å™¨ä¸‹ï¼Œ`Semaphore` çš„å®ç°ä¼¼ä¹å¹¶ä¸éœ€è¦å†…éƒ¨çš„ `Mutex` è¿›è¡Œä¿æŠ¤ï¼Œåªéœ€è¦å¤–éƒ¨çš„ `RwLock` è¿›è¡Œä¿æŠ¤å³å¯ã€‚

    ä½†åœ¨å¤šæ ¸å¤„ç†å™¨ä¸‹ï¼Œ`Semaphore` çš„å®ç°å¯èƒ½ä¼šæ¶‰åŠåˆ°å¤šä¸ªæ ¸å¿ƒçš„å¹¶å‘è®¿é—®ï¼Œå› æ­¤éœ€è¦ä½¿ç”¨ `Mutex` æ¥æä¾›æ›´ç»†ç²’åº¦çš„é”ä¿æŠ¤ã€‚åœ¨è¿›è¡Œæ·»åŠ ã€åˆ é™¤æ“ä½œæ—¶ï¼Œå¯¹ `RwLock` ä½¿ç”¨ `write` è·å–å†™é”ï¼Œè€Œåœ¨è¿›è¡Œ `signal`ã€`wait` æ“ä½œæ—¶ï¼Œå¯¹ `RwLock` ä½¿ç”¨ `read` æ¥è·å–æ›´å¥½çš„æ€§èƒ½å’Œæ§åˆ¶ã€‚

    ç»¼ä¸Šè€ƒé‡ï¼Œè¿™é‡Œå°±ä¿ç•™äº† `Mutex` çš„ä½¿ç”¨ã€‚

è¯·å‚è€ƒå®éªŒä»£ç ç»™å‡ºçš„ç›¸å…³æ³¨é‡Šå†…å®¹ï¼Œå®Œæˆä¿¡å·é‡çš„å®ç°ã€‚æœ€åå°† `Semaphore` çš„æ“ä½œå±‚å±‚å‘ä¸Šä¼ é€’ï¼ˆæˆ–è€…è¯´è‡ªä¸Šå‘ä¸‹å±‚å±‚å§”æ‰˜å…·ä½“å®ç°ï¼‰ï¼Œå®ç°ä½œä¸ºç³»ç»Ÿè°ƒç”¨çš„ `sys_sem`ï¼š

```rust
pub fn sys_sem(args: &SyscallArgs, context: &mut ProcessContext) {
    match args.arg0 {
        0 => context.set_rax(new_sem(args.arg1 as u32, args.arg2)),
        1 => context.set_rax(remove_sem(args.arg1 as u32)),
        2 => sem_siganl(args.arg1 as u32, context),
        3 => sem_wait(args.arg1 as u32, context),
        _ => context.set_rax(usize::MAX),
    }
}
```

!!! tip "è®°å¾—å®Œå–„ç”¨æˆ·ä¾§ `pkg/lib/src/sync.rs` ä¸­å¯¹ä¿¡å·é‡çš„æ“ä½œ"

### æµ‹è¯•ä»»åŠ¡

åœ¨å®ç°äº† `SpinLock` å’Œ `Semaphore` çš„åŸºç¡€ä¸Šï¼Œä½ éœ€è¦å®Œæˆå¦‚ä¸‹çš„ç”¨æˆ·ç¨‹åºä»»åŠ¡æ¥æµ‹è¯•ä½ çš„å®ç°ï¼š

#### å¤šçº¿ç¨‹è®¡æ•°å™¨

åœ¨æ‰€ç»™ä»£ç çš„ `pkg/app/counter` ä¸­å®ç°äº†ä¸€ä¸ªå¤šçº¿ç¨‹è®¡æ•°å™¨ï¼Œå¤šä¸ªçº¿ç¨‹å¯¹ä¸€ä¸ªå…±äº«çš„è®¡æ•°å™¨è¿›è¡Œç´¯åŠ æ“ä½œï¼Œæœ€ç»ˆè¾“å‡ºè®¡æ•°å™¨çš„å€¼ã€‚

ä¸ºäº†æä¾›è¶³å¤Ÿå¤§çš„å¯èƒ½æ€§æ¥è§¦å‘ç«æ€æ¡ä»¶ï¼Œè¯¥ç¨‹åºä½¿ç”¨äº†ä¸€äº›æ‰‹æ®µæ¥åˆ»æ„æ„é€ ä¸€ä¸ªä¸´ç•ŒåŒºï¼Œè¿™éƒ¨åˆ†ä»£ç ä¸åº”è¢«ä¿®æ”¹ã€‚

ä½ éœ€è¦é€šè¿‡ä¸Šè¿°**ä¸¤ç§æ–¹å¼**ï¼Œåˆ†åˆ«ä¿æŠ¤è¯¥ä¸´ç•ŒåŒºï¼Œä½¿å¾—è®¡æ•°å™¨çš„å€¼æœ€ç»ˆä¸º `800`ã€‚

!!! note "å°è¯•ä¿®æ”¹ä»£ç ï¼Œä½¿ç”¨**ä¸¤ç»„çº¿ç¨‹**åˆ†åˆ«æµ‹è¯• `SpinLock` å’Œ `Semaphore`"

    ä¸€ä¸ªå‚è€ƒä»£ç è¡Œä¸ºå¦‚ä¸‹ï¼Œä½ å¯ä»¥åœ¨ `test_spin` å’Œ `test_semaphore` ä¸­åˆ†åˆ«ç»§ç»­ `fork` æ›´å¤šçš„è¿›ç¨‹ç”¨æ¥å®é™…æµ‹è¯•ï¼š

    ```rust
    fn main() -> isize {
        let pid = sys_fork();

        if pid == 0 {
            test_semaphore();
        } else {
            test_spin();
            sys_wait_pid(pid);
        }

        0
    }
    ```

#### æ¶ˆæ¯é˜Ÿåˆ—

åˆ›å»ºä¸€ä¸ªç”¨æˆ·ç¨‹åº `pkg/app/mq`ï¼Œç»“åˆä½¿ç”¨ä¿¡å·é‡ï¼Œå®ç°ä¸€ä¸ªæ¶ˆæ¯é˜Ÿåˆ—ï¼š

- çˆ¶è¿›ç¨‹ä½¿ç”¨ fork åˆ›å»ºé¢å¤– 16 ä¸ªè¿›ç¨‹ï¼Œå…¶ä¸­ä¸€åŠä¸ºç”Ÿäº§è€…ï¼Œä¸€åŠä¸ºæ¶ˆè´¹è€…ã€‚
- ç”Ÿäº§è€…ä¸æ–­åœ°å‘æ¶ˆæ¯é˜Ÿåˆ—ä¸­å†™å…¥æ¶ˆæ¯ï¼Œæ¶ˆè´¹è€…ä¸æ–­åœ°ä»æ¶ˆæ¯é˜Ÿåˆ—ä¸­è¯»å–æ¶ˆæ¯ã€‚
- æ¯ä¸ªçº¿ç¨‹å¤„ç†çš„æ¶ˆæ¯æ€»é‡å…± 10 æ¡ï¼ˆå³ç”Ÿäº§è€…ä¼šäº§ç”Ÿ 10 ä¸ªæ¶ˆæ¯ï¼Œæ¯ä¸ªæ¶ˆè´¹è€…åªæ¶ˆè´¹ 10 ä¸ªæ¶ˆæ¯ï¼‰ã€‚
- åœ¨æ¯ä¸ªçº¿ç¨‹ç”Ÿäº§æˆ–æ¶ˆè´¹çš„æ—¶å€™ï¼Œè¾“å‡ºç›¸å…³çš„ä¿¡æ¯ã€‚
- åœ¨ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…å®Œæˆä¸Šè¿°æ“ä½œåï¼Œä½¿ç”¨ `sys_exit(0)` ç›´æ¥é€€å‡ºã€‚
- æœ€ç»ˆä½¿ç”¨çˆ¶è¿›ç¨‹ç­‰å¾…å…¨éƒ¨çš„å­è¿›ç¨‹é€€å‡ºåï¼Œè¾“å‡ºæ¶ˆæ¯é˜Ÿåˆ—çš„æ¶ˆæ¯æ•°é‡ã€‚
- åœ¨çˆ¶è¿›ç¨‹åˆ›å»ºå®Œæˆ 16 ä¸ªè¿›ç¨‹åï¼Œä½¿ç”¨ `sys_stat` è¾“å‡ºå½“å‰çš„å…¨éƒ¨è¿›ç¨‹çš„ä¿¡æ¯ã€‚

ä½ éœ€è¦ä¿è¯æœ€ç»ˆæ¶ˆæ¯é˜Ÿåˆ—ä¸­çš„æ¶ˆæ¯æ•°é‡ä¸º 0ï¼Œä½ å¯ä»¥å¼€å¯å†…æ ¸æ›´åŠ è¯¦ç»†çš„æ—¥å¿—ï¼Œå¹¶ä½¿ç”¨è¾“å‡ºçš„ç›¸å…³ä¿¡æ¯å°è¯•è¯æ˜é˜Ÿåˆ—çš„æ­£å¸¸å·¥ä½œï¼š

- åœ¨ä»é˜Ÿåˆ—å–å‡ºæ¶ˆæ¯æ—¶ï¼Œæ¶ˆæ¯ä¸ºç©ºå—ï¼Ÿ
- åœ¨å‘é˜Ÿåˆ—å†™å…¥æ¶ˆæ¯æ—¶ï¼Œé˜Ÿåˆ—æ˜¯å¦æ»¡äº†ï¼Ÿ
- åœ¨é˜Ÿåˆ—ä¸ºç©ºæ—¶ï¼Œæ¶ˆè´¹è€…æ˜¯å¦è¢«é˜»å¡ï¼Ÿ
- åœ¨é˜Ÿåˆ—æ»¡æ—¶ï¼Œç”Ÿäº§è€…æ˜¯å¦è¢«é˜»å¡ï¼Ÿ

#### å“²å­¦å®¶çš„æ™šé¥­

å‡è®¾æœ‰ 5 ä¸ªå“²å­¦å®¶ï¼Œä»–ä»¬çš„ç”Ÿæ´»åªæ˜¯æ€è€ƒå’Œåƒé¥­ã€‚è¿™äº›å“²å­¦å®¶å…±ç”¨ä¸€ä¸ªåœ†æ¡Œï¼Œæ¯ä½éƒ½æœ‰ä¸€æŠŠæ¤…å­ã€‚åœ¨æ¡Œå­ä¸­å¤®æœ‰ä¸€ç¢—ç±³é¥­ï¼Œåœ¨æ¡Œå­ä¸Šæ”¾ç€ 5 æ ¹ç­·å­ã€‚

å½“ä¸€ä½å“²å­¦å®¶æ€è€ƒæ—¶ï¼Œä»–ä¸å…¶ä»–åŒäº‹ä¸äº¤æµã€‚æ—¶è€Œï¼Œä»–ä¼šæ„Ÿåˆ°é¥¥é¥¿ï¼Œå¹¶è¯•å›¾æ‹¿èµ·ä¸ä»–ç›¸è¿‘çš„ä¸¤æ ¹ç­·å­ï¼ˆç­·å­åœ¨ä»–å’Œä»–çš„å·¦æˆ–å³é‚»å±…ä¹‹é—´ï¼‰ã€‚ä¸€ä¸ªå“²å­¦å®¶ä¸€æ¬¡åªèƒ½æ‹¿èµ·ä¸€æ ¹ç­·å­ã€‚æ˜¾ç„¶ï¼Œä»–ä¸èƒ½ä»å…¶ä»–å“²å­¦å®¶æ‰‹é‡Œæ‹¿èµ°ç­·å­ã€‚å½“ä¸€ä¸ªé¥¥é¥¿çš„å“²å­¦å®¶åŒæ—¶æ‹¥æœ‰ä¸¤æ ¹ç­·å­æ—¶ï¼Œä»–å°±èƒ½åƒã€‚åœ¨åƒå®Œåï¼Œä»–ä¼šæ”¾ä¸‹ä¸¤æ ¹ç­·å­ï¼Œå¹¶å¼€å§‹æ€è€ƒã€‚

åˆ›å»ºä¸€ä¸ªç”¨æˆ·ç¨‹åº `pkg/app/dinner`ï¼Œä½¿ç”¨ä½ è¯¾ä¸Šå­¦åˆ°çš„çŸ¥è¯†ï¼Œå®ç°å¹¶è§£å†³å“²å­¦å®¶å°±é¤é—®é¢˜ã€‚ä½ å¯ä»¥å‚è€ƒä»¥ä¸‹æ€è·¯ï¼š

- åˆ›å»ºä¸€ä¸ªç¨‹åºï¼Œæ¨¡æ‹Ÿäº”ä¸ªå“²å­¦å®¶çš„è¡Œä¸ºã€‚
- æ¯ä¸ªå“²å­¦å®¶éƒ½æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„çº¿ç¨‹ï¼Œå¯ä»¥åŒæ—¶è¿›è¡Œæ€è€ƒå’Œå°±é¤ã€‚
- ä½¿ç”¨äº’æ–¥é”æ¥ä¿æŠ¤æ¯ä¸ªç­·å­ï¼Œç¡®ä¿åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªå“²å­¦å®¶å¯ä»¥æ‹¿èµ·ä¸€æ ¹ç­·å­ã€‚
- å“²å­¦å®¶çš„æ€è€ƒå’Œå°±é¤æ—¶é—´å¯ä»¥éšæœºç”Ÿæˆï¼Œä»¥å¢åŠ å¹¶å‘æ€§å’Œå®é™…æ€§ã€‚
- å½“å“²å­¦å®¶æˆåŠŸå°±é¤æ—¶ï¼Œè¾“å‡ºç›¸å…³ä¿¡æ¯ï¼Œå¦‚å“²å­¦å®¶ç¼–å·ã€å°±é¤æ—¶é—´ç­‰ã€‚
- åœ¨ç¨‹åºä¸­å¼•å…¥ä¸€äº›éšæœºæ€§ï¼Œä¾‹å¦‚åœ¨å°è¯•æ‹¿ç­·å­æ—¶å¼•å…¥ä¸€å®šçš„å»¶è¿Ÿï¼Œä»¥æ¨¡æ‹Ÿç«äº‰æ¡ä»¶å’Œèµ„æºäº‰ç”¨ã€‚
- å¯ä»¥è®¾ç½®ç­‰å¾…æ—¶é—´æˆ–å¾ªç¯æ¬¡æ•°ï¼Œä»¥ç¡®ä¿ç¨‹åºèƒ½å¤Ÿè¿è¡Œè¶³å¤Ÿé•¿çš„æ—¶é—´ï¼Œä»è€Œè§‚å¯Ÿåˆ°ä¸åŒçš„æƒ…å†µï¼Œå¦‚æ­»é”å’Œé¥¥é¥¿ã€‚

é€šè¿‡è§‚å¯Ÿç¨‹åºçš„è¾“å‡ºå’Œè¡Œä¸ºï¼Œè¯·æˆªå›¾è®°å½•ä»¥ä¸‹ç°è±¡ï¼Œå¹¶ä»‹ç»ä½ çš„è§£å†³æ€è·¯ï¼š

- å“²å­¦å®¶æ˜¯å¦èƒ½å¤ŸæˆåŠŸå°±é¤ï¼Œå³åŒæ—¶æ‹¿åˆ°å·¦å³ä¸¤ä¾§çš„ç­·å­ã€‚
- æ˜¯å¦å­˜åœ¨æ­»é”æƒ…å†µï¼Œå³æ‰€æœ‰å“²å­¦å®¶éƒ½æ— æ³•åŒæ—¶æ‹¿åˆ°ä»–ä»¬éœ€è¦çš„ç­·å­ã€‚
- æ˜¯å¦å­˜åœ¨é¥¥é¥¿æƒ…å†µï¼Œå³æŸäº›å“²å­¦å®¶æ— æ³•è·å¾—è¶³å¤Ÿçš„æœºä¼šå°±é¤ã€‚

## æ€è€ƒé¢˜

1. åœ¨ Lab 2 ä¸­è®¾è®¡è¾“å…¥ç¼“å†²åŒºæ—¶ï¼Œå¦‚æœä¸ä½¿ç”¨æ— é”é˜Ÿåˆ—å®ç°ï¼Œè€Œé€‰æ‹©ä½¿ç”¨ `Mutex` å¯¹ä¸€ä¸ªåŒæ­¥é˜Ÿåˆ—è¿›è¡Œä¿æŠ¤ï¼Œåœ¨ç¼–å†™ç›¸å…³å‡½æ•°æ—¶éœ€è¦æ³¨æ„ä»€ä¹ˆé—®é¢˜ï¼Ÿè€ƒè™‘åœ¨è¿›è¡Œ `pop` æ“ä½œè¿‡ç¨‹ä¸­é‡åˆ°ä¸²å£è¾“å…¥ä¸­æ–­çš„æƒ…å½¢ï¼Œå°è¯•æè¿°é‡åˆ°é—®é¢˜çš„åœºæ™¯ï¼Œå¹¶æå‡ºè§£å†³æ–¹æ¡ˆã€‚

2. åœ¨è¿›è¡Œ `fork` çš„å¤åˆ¶å†…å­˜çš„è¿‡ç¨‹ä¸­ï¼Œç³»ç»Ÿçš„å½“å‰é¡µè¡¨ã€è¿›ç¨‹é¡µè¡¨ã€å­è¿›ç¨‹é¡µè¡¨ã€å†…æ ¸é¡µè¡¨ç­‰ä¹‹é—´çš„å…³ç³»æ˜¯æ€æ ·çš„ï¼Ÿåœ¨è¿›è¡Œå†…å­˜å¤åˆ¶æ—¶ï¼Œéœ€è¦æ³¨æ„å“ªäº›é—®é¢˜ï¼Ÿ

3. ä¸ºä»€ä¹ˆåœ¨å®éªŒçš„å®ç°ä¸­ï¼Œ`fork` ç³»ç»Ÿè°ƒç”¨å¿…é¡»åœ¨ä»»ä½• Rust å†…å­˜åˆ†é…ï¼ˆå †å†…å­˜åˆ†é…ï¼‰ä¹‹å‰è¿›è¡Œï¼Ÿå¦‚æœåœ¨å †å†…å­˜åˆ†é…ä¹‹åè¿›è¡Œ `fork`ï¼Œä¼šæœ‰ä»€ä¹ˆé—®é¢˜ï¼Ÿ

4. è¿›è¡ŒåŸå­æ“ä½œæ—¶å€™çš„ `Ordering` å‚æ•°æ˜¯ä»€ä¹ˆï¼Ÿæ­¤å¤„ Rust å£°æ˜çš„å†…å®¹ä¸ [C++20 è§„èŒƒ](https://en.cppreference.com/w/cpp/atomic/memory_order) ä¸­çš„ä¸€è‡´ï¼Œå°è¯•æœç´¢å¹¶ç®€å•äº†è§£ç›¸å…³å†…å®¹ï¼Œç®€å•ä»‹ç»è¯¥æšä¸¾çš„æ¯ä¸ªå€¼å¯¹åº”äºä»€ä¹ˆå«ä¹‰ã€‚

5. åœ¨å®ç° `SpinLock` çš„æ—¶å€™ï¼Œä¸ºä»€ä¹ˆéœ€è¦å®ç° `Sync` traitï¼Ÿä¸ä¹‹ç±»ä¼¼çš„ `Send` trait åˆæ˜¯ä»€ä¹ˆå«ä¹‰ï¼Ÿ

6. `core::hint::spin_loop` ä½¿ç”¨çš„ `pause` æŒ‡ä»¤å’Œ Lab 4 ä¸­çš„ `x86_64::instructions::hlt` æŒ‡ä»¤æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿè¿™é‡Œä¸ºä»€ä¹ˆä¸èƒ½ä½¿ç”¨ `hlt` æŒ‡ä»¤ï¼Ÿ

## åŠ åˆ†é¡¹

1. ğŸ¤” å‚è€ƒä¿¡å·é‡ç›¸å…³ç³»ç»Ÿè°ƒç”¨çš„å®ç°ï¼Œå°è¯•ä¿®æ”¹ `waitpid` ç³»ç»Ÿè°ƒç”¨ï¼Œåœ¨è¿›ç¨‹ç­‰å¾…å¦ä¸€ä¸ªè¿›ç¨‹é€€å‡ºæ—¶è¿›è¡Œé˜»å¡ï¼Œå¹¶åœ¨ç›®æ ‡è¿›ç¨‹é€€å‡ºåæºå¸¦è¿”å›å€¼å”¤é†’è¿›ç¨‹ã€‚

2. ğŸ¤” å°è¯•å®ç°å¦‚ä¸‹ç¨‹åºä»»åŠ¡ï¼š

    - åˆ›å»ºä¸‰ä¸ªå­è¿›ç¨‹ï¼Œè®©å®ƒä»¬åˆ†åˆ«èƒ½è¾“å‡ºä¸”åªèƒ½è¾“å‡º `>`ï¼Œ`<` å’Œ `_`ã€‚
    - å¯¹è¿™äº›å­è¿›ç¨‹è¿›è¡ŒåŒæ­¥ï¼Œä½¿å¾—æ‰“å°å‡ºçš„åºåˆ—æ€»æ˜¯ `<><_` å’Œ `><>_` ç»„åˆã€‚

    åœ¨å®Œæˆè¿™ä¸€ä»»åŠ¡çš„åŸºç¡€ä¸Šï¼Œå…¶ä»–ç»†èŠ‚å¯ä»¥è‡ªè¡Œå†³å®šå¦‚ä½•å®ç°ï¼ŒåŒ…æ‹¬è¾“å‡ºé•¿åº¦ç­‰ã€‚

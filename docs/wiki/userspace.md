# 用户空间

# 用户态与内核态”概述

从执行原理来说，不同进程的指令均运行在同一个处理器上，基于同一个处理器访问系统资源。但从资源管理、崩溃预防的角度来看，操作系统需隔离敏感资源，限制不同进程的可以执行的指令以及它可以访问的地址空间范围。因此，现代操作系统通常会将进程分为两种状态：用户态（user mode）和内核态（kernel mode）。

- 用户态（用户空间）是指进程运行在低特权级别，只能执行受限指令，访问受限资源；
- 内核态是指进程运行在高特权级别，可以执行特权指令，并且可以直接访问所有系统资源。

用户态、内核态的区分有处理器提供硬件支持。处理器通常是用某个控制寄存器中的一个模式位（mode bit）来提供这种功能的存器描述了进程当前享有的特权。当设置了模式位时，进程就运行在内核态中。一个运行在内核态的进程可以执行指令集中的任何指令,并访问系统中的任何内存位置。

当没有设置模式位时，进程就运行在用户态中。用户态中的进程不允许执行特权指令（privileged instruction），比如停止处理器、改变模式位，或者发起一个 I/O 操作。也不用户模式中的进程直接引用地址空间中内核区内的代码和数据。**任何这样的尝试都会导致致命的保护故障**，如一般保护故障、缺页异常（Page Fault）等。

!!! note "关于一般保护故障"
    一般保护故障（General Protection Fault，通常缩写为 GPF）是操作系统在发现进程试图执行非法、未授权的或特权级别不足的操作时产生的一种异常。

反之，用户程序必须通过系统调用接口**间接地**访问内核代码和数据。运行应用程序代码的进程初始时是在用户模式中的。进程从用户模式变为内核模唯一方法是通过诸如中断、故障或者陷入系统调用这样的异常。当异常发生时，控制到异常处理程序，处理器将模式从用户模式变为内核模式。处理程序运行在内核模中当它返回到应用程序代码时，处理器就把模式从内核模式改回到用户模式。

## ring

在x86_64体系结构中，操作系统和应用程序运行在不同的特权级别（privilege levels）中，这些级别被称为 "ring"。一般来说，较*低*的数字代表更*高*的特权级别。具体来说：ring 0 对应为上文的内核态（kernel mode）；ring 3对应为上文的用户态（user mode）。  

!!! question "为什么大家不用 ring 1/2？"

1. **内存保护的粒度问题：** 虽然 x86 CPU 提供了四个特权级别，但对应特权只能在内存段粒度生效，而非现代操作系统所期待的更细粒度的内存保护。因此，现代大多数x86操作系统忽略段机制，而是依赖基于页表项（PTEs）的保护机制。而目前 x86 体系结构页表项的保护机制只有两个特权级别，即用户态和内核态。

2. **可移植性问题：** 操作系统的设计者考虑需到跨平台的可移植性，不仅仅是限于 x86 架构。为了保持操作系统的可移植性，不依赖于特定处理器架构上的特权级别数量，而是统一使用两个特权级别，使得操作系统更易于在不同的处理器架构上移植和运行。

3. **历史遗留问题：** x86 架构的设计早于现代操作系统的实现，许多 x86 的系统编程特性在设计时并不清楚操作系统将如何使用。随着现代操作系统对 x86 架构的深入了解和不断发展，许多早期设计的特性被现代操作系统所忽略，包括段机制和任务状态段等。对于 x64 架构，一些被废弃的特性被省略，使得操作系统可以更加简洁地设计和实现。


## 参考资料

- [Getting to Ring 3 - OSDev](https://wiki.osdev.org/Getting_to_Ring_3)
- [Security - OSDev](https://wiki.osdev.org/Security)
- [Protection ring - Wikipedia](https://en.wikipedia.org/wiki/Protection_ring)
- [Computer Systems: A Programmer's Perspective]（http://www.csapp.cs.cmu.edu/3e/home.html）
- [Why do x86 CPUs only use 2 out of 4 rings?]（https://superuser.com/questions/1063420/why-do-x86-cpus-only-use-2-out-of-4-rings）
- [PTE & Paging] (https://wiki.osdev.org/Paging)